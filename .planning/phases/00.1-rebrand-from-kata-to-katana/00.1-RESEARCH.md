# Phase 0.1: Rebrand from Kata to Katana - Research

**Researched:** 2026-01-18
**Domain:** Codebase-wide text replacement and directory renaming
**Confidence:** HIGH

<research_summary>
## Summary

This research documents the complete scope of the Kata-to-Katana rebrand across the codebase. The rebrand touches 98 files containing 1,105 total occurrences of "Kata" (case variations), plus directory names and file names that need renaming.

The standard approach is a systematic multi-pass replacement strategy: rename directories first, then files, then update file contents from outer references inward (package.json and entry points first, then documentation, then internal files).

**Primary recommendation:** Execute in strict order: (1) directory renames, (2) file renames, (3) content updates by category. Use `git mv` for all renames to preserve history. Batch verify each category before moving to next.
</research_summary>

<standard_stack>
## Standard Stack

No external libraries required. This is a text replacement and rename operation using:

### Core Tools
| Tool | Purpose | Why Standard |
|------|---------|--------------|
| `git mv` | Directory/file renames | Preserves git history |
| `sed`/native editor | Text replacement | Built-in, reliable |
| `grep -r` | Verification | Confirms all replacements |

### Replacement Patterns
| Pattern | Replace With | Occurrences |
|---------|--------------|-------------|
| `kata` (lowercase) | `katana` | ~800+ |
| `Kata` (title case) | `Katana` | ~280+ |
| `KATA` (uppercase) | `KATANA` | ~25 |
| `/kata:` (command prefix) | `/katana:` | All commands |
| `kata-` (file prefix) | `katana-` | 13 files |
| `gsd:` (legacy prefix) | `katana:` | 7 files |
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Directory Structure Changes

```
CURRENT                         AFTER RENAME
kata/                      ->   katana/
  references/                     references/
  templates/                      templates/
  workflows/                      workflows/

commands/kata/             ->   commands/katana/
  (24 command files)              (24 command files)

agents/
  kata-*.md (11 files)     ->   katana-*.md (11 files)

hooks/
  kata-check-update.js     ->   katana-check-update.js
```

### File Rename Pattern

**Agent files (11 files):**
```
agents/kata-codebase-mapper.md    -> agents/katana-codebase-mapper.md
agents/kata-debugger.md           -> agents/katana-debugger.md
agents/kata-executor.md           -> agents/katana-executor.md
agents/kata-integration-checker.md -> agents/katana-integration-checker.md
agents/kata-phase-researcher.md   -> agents/katana-phase-researcher.md
agents/kata-plan-checker.md       -> agents/katana-plan-checker.md
agents/kata-planner.md            -> agents/katana-planner.md
agents/kata-project-researcher.md -> agents/katana-project-researcher.md
agents/kata-research-synthesizer.md -> agents/katana-research-synthesizer.md
agents/kata-roadmapper.md         -> agents/katana-roadmapper.md
agents/kata-verifier.md           -> agents/katana-verifier.md
```

**Hook files (1 file):**
```
hooks/kata-check-update.js        -> hooks/katana-check-update.js
```

**Root files (2 files):**
```
KATA-STYLE.md                     -> KATANA-STYLE.md
kata.code-workspace               -> katana.code-workspace
```

### Content Update Categories

**1. Package Identity (1 file) - CRITICAL**
```json
// package.json
{
  "name": "kata-cli" -> "katana-cli",
  "bin": { "kata": ... } -> { "katana": ... },
  "repository.url": "...kata.git" -> "...katana.git"
}
```

**2. Install Script (1 file) - CRITICAL**
```javascript
// bin/install.js
// ASCII banner, command references, hook paths
// ~34 occurrences
```

**3. README (1 file) - HIGH VISIBILITY**
```markdown
// README.md - Public-facing documentation
// ~57 occurrences including:
// - Title, descriptions
// - npm package names
// - Command examples (/kata:*)
// - GitHub URLs
// - Troubleshooting paths
```

**4. Commands (26 files)**
```markdown
// commands/kata/*.md
// YAML frontmatter: name: kata:command-name -> katana:command-name
// Internal references to /kata: commands
```

**5. Agents (11 files)**
```markdown
// agents/kata-*.md
// File path references
// Internal agent names
```

**6. Workflows (12 files)**
```markdown
// kata/workflows/*.md
// @-references to kata/ paths
// Command references
```

**7. Templates (22 files)**
```markdown
// kata/templates/**/*.md
// @-references
// Example commands
```

**8. References (7 files)**
```markdown
// kata/references/*.md
// @-references
// Command examples
```

**9. Planning Files (30+ files)**
```markdown
// .planning/**/*.md
// Historical references (some should remain as-is for history)
// Active references need updating
```

**10. Hooks (2 files)**
```javascript
// hooks/*.js
// Cache paths, version file paths
```

**11. Miscellaneous**
```
CLAUDE.md (1 occurrence)
CHANGELOG.md (4 occurrences)
.gitignore (1 occurrence)
assets/terminal.svg (5 occurrences in ASCII art)
```
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Case-sensitive replacement | Single regex | Multiple passes | "kata" vs "Kata" vs "KATA" have different semantics |
| Git history | `rm` + `cp` | `git mv` | Preserves blame, history |
| Bulk replacement | `sed -i` on all files | Category-by-category | Need verification between categories |
| Verification | Manual review | `grep -r kata` after | Too many files for manual verification |

**Key insight:** The complexity is not in the replacement itself but in the ordering and verification. A naive `sed -i 's/kata/katana/g' **/*` would work but makes verification impossible. Category-by-category with commits allows verification and rollback.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Breaking Git History
**What goes wrong:** Using `rm` and `mkdir` loses git history for renamed files
**Why it happens:** Forgetting that `git mv` preserves history
**How to avoid:** Always use `git mv` for directory and file renames
**Warning signs:** `git log --follow` shows no history before rename

### Pitfall 2: Case Sensitivity Collisions
**What goes wrong:** `kata` in code becomes `katana` but `Kata` in docs becomes `Katana` inconsistently
**Why it happens:** Single-pass global replacement
**How to avoid:** Process each case variant separately: lowercase first, then title case, then uppercase
**Warning signs:** Mixed casing in output (e.g., "Katana-cli" instead of "katana-cli")

### Pitfall 3: Breaking Cross-References
**What goes wrong:** Renaming `kata/` directory before updating file contents breaks @-references
**Why it happens:** Files reference `@~/.claude/kata/...` paths
**How to avoid:** Update file contents AFTER directory renames, or update content references to new paths first
**Warning signs:** `@~/.claude/kata/...` paths in files after `kata/` is renamed

### Pitfall 4: npm Package Name Conflict
**What goes wrong:** `katana-cli` may already exist on npm
**Why it happens:** Not checking npm registry
**How to avoid:** Run `npm view katana-cli` before committing to name
**Warning signs:** `npm publish` fails with "package already exists"

### Pitfall 5: Incomplete Legacy Reference Removal
**What goes wrong:** Old `gsd:` command prefixes remain
**Why it happens:** Only replacing `kata:` prefixes, missing the older `gsd:` format
**How to avoid:** Search for BOTH `kata:` AND `gsd:` prefixes and update both to `katana:`
**Warning signs:** Commands like `/gsd:execute-phase` still appear in docs

### Pitfall 6: ASCII Art Banner Corruption
**What goes wrong:** ASCII art banner becomes malformed
**Why it happens:** Binary block characters in terminal.svg and install.js need character-by-character replacement
**How to avoid:** Generate new ASCII art for "KATANA" rather than editing existing "KATA"
**Warning signs:** Misaligned characters in terminal banner

### Pitfall 7: Historical References in Planning
**What goes wrong:** Updating historical references breaks context
**Why it happens:** `.planning/phases/00-*` files document past decisions using "Kata" terminology
**How to avoid:** Only update ACTIVE references, not historical narrative
**Warning signs:** Historical commit messages referenced in docs become inconsistent
</common_pitfalls>

<code_examples>
## Code Examples

### Directory Rename Sequence
```bash
# Order matters - rename from deepest to shallowest
git mv commands/kata commands/katana
git mv kata katana
```

### File Rename Pattern
```bash
# Agent files
for f in agents/kata-*.md; do
  git mv "$f" "${f/kata-/katana-}"
done

# Hook files
git mv hooks/kata-check-update.js hooks/katana-check-update.js

# Root files
git mv KATA-STYLE.md KATANA-STYLE.md
git mv kata.code-workspace katana.code-workspace
```

### Content Replacement Patterns
```bash
# Lowercase (most common)
sed -i '' 's/kata/katana/g' file.md

# Title case (documentation)
sed -i '' 's/Kata/Katana/g' file.md

# Uppercase (constants, headers)
sed -i '' 's/KATA/KATANA/g' file.md

# Command prefix
sed -i '' 's|/kata:|/katana:|g' file.md

# Legacy prefix
sed -i '' 's|/gsd:|/katana:|g' file.md

# File path references (after rename)
sed -i '' 's|kata/|katana/|g' file.md
sed -i '' 's|kata-|katana-|g' file.md
```

### ASCII Art Banner (KATANA)
```
  ██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗
  ██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗
  █████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║
  ██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║
  ██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║
  ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝
```

### Verification Commands
```bash
# Check for remaining kata references (should be 0 after completion)
grep -ri "kata" --include="*.md" --include="*.js" --include="*.json" . | grep -v ".git" | grep -v "node_modules"

# Check for remaining gsd: prefixes (should be 0)
grep -ri "/gsd:" --include="*.md" . | grep -v ".git"

# Verify all commands have katana: prefix
grep -r "name: kata:" commands/katana/*.md
```
</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual regex | IDE bulk replace | Always | VSCode/vim mass replace is safer |
| Single commit | Category commits | Best practice | Allows verification and rollback |

**Relevant to this rebrand:**
- No external tools needed - this is a straightforward text/rename operation
- Modern editors (VSCode, Claude Code) can do search-replace across files

**npm naming notes:**
- Need to verify `katana-cli` is available on npm
- If taken, alternatives: `@katana/cli`, `katana-dev`, `katana-code`
</sota_updates>

<open_questions>
## Open Questions

1. **npm Package Name Availability**
   - What we know: Current name is `kata-cli`, want `katana-cli`
   - What's unclear: Is `katana-cli` available on npm registry?
   - Recommendation: Run `npm view katana-cli` before planning; if taken, decide on alternative

2. **GitHub Repository URL**
   - What we know: Current is `github.com/gannonh/kata`
   - What's unclear: Will repo be renamed to `katana`?
   - Recommendation: If repo stays `kata`, some URLs need to remain; if renamed, update all

3. **Historical Planning Files**
   - What we know: `.planning/phases/00-*` files reference "Kata" in historical context
   - What's unclear: Should historical narrative be updated or preserved?
   - Recommendation: Preserve historical references, update active/template references only

4. **Backward Compatibility**
   - What we know: Users have installed `kata-cli` globally
   - What's unclear: Should there be a deprecation warning or migration path?
   - Recommendation: Consider npm alias from `kata-cli` to `katana-cli` for transition period
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- Direct codebase analysis via Grep/Glob
- File content inspection via Read
- File counts: 98 files, 1105 occurrences

### Verification Data
```
Files by category:
- commands/kata/*.md: 26 files
- kata/templates/**/*.md: 22 files
- kata/workflows/*.md: 12 files
- agents/kata-*.md: 11 files
- kata/references/*.md: 7 files
- hooks/*.js: 2 files
- Root files: 8 files (README, package.json, etc.)
- .planning/**/*.md: 30+ files
```
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Text replacement, git operations
- Ecosystem: bash, sed, git mv
- Patterns: Multi-pass replacement, category-by-category
- Pitfalls: History preservation, case sensitivity, ASCII art

**Confidence breakdown:**
- File inventory: HIGH - direct grep/glob analysis
- Replacement patterns: HIGH - examined file contents
- Pitfalls: HIGH - based on common rename mistakes
- ASCII art: MEDIUM - need to verify KATANA banner renders correctly

**Research date:** 2026-01-18
**Valid until:** N/A (internal operation, not dependent on external libraries)
</metadata>

---

## Execution Order Summary

**Phase 0.1 should be planned with this order:**

1. **Pre-flight checks**
   - Verify npm name availability
   - Confirm repo rename decision

2. **Directory renames** (git mv)
   - `commands/kata/` -> `commands/katana/`
   - `kata/` -> `katana/`

3. **File renames** (git mv)
   - 11 agent files
   - 1 hook file
   - 2 root files (KATA-STYLE.md, kata.code-workspace)

4. **Content updates by category**
   - Critical: package.json (name, bin, repository)
   - Critical: bin/install.js (banner, paths, messages)
   - Critical: README.md (all public-facing)
   - High: commands/*.md (YAML frontmatter, content)
   - High: agents/*.md (paths, references)
   - Medium: workflows, templates, references
   - Medium: hooks/*.js
   - Low: .planning files (selective)
   - Special: assets/terminal.svg (ASCII art)

5. **Verification**
   - grep for remaining kata/Kata/KATA
   - grep for remaining gsd: prefixes
   - Test installation flow

6. **Commit and tag**

---

*Phase: 00.1-rebrand-from-kata-to-katana*
*Research completed: 2026-01-18*
*Ready for planning: yes*
