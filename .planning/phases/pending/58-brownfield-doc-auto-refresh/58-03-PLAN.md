---
phase: 58-brownfield-doc-auto-refresh
plan: 03
type: execute
wave: 2
depends_on: [01]
files_modified:
  - skills/kata-execute-phase/SKILL.md
autonomous: true
must_haves:
  truths:
    - Step 7.25 gate widened to trigger on index.json OR .planning/codebase/ directory
    - BROWNFIELD_STALE initialized to "false" before JSON parsing
    - Step 7.25 reads brownfieldDocStale from detect-stale-intel.cjs JSON output
    - When brownfieldDocStale is true, orchestrator spawns 4 mapper agents via Task() calls
    - Refreshed .planning/codebase/ and .planning/intel/ are git-staged before SCAN_RAN=true
    - Mapper agents receive inlined instructions from codebase-mapper-instructions.md
    - After mapper agents complete, orchestrator runs generate-intel.js then scan-codebase.cjs
    - SCAN_RAN is set to true after brownfield auto-refresh completes
    - Doc gardening warning is replaced by auto-refresh action
    - All auto-refresh operations are non-blocking (failures log and continue)
    - TOTAL_FILES computation handles missing index.json gracefully (defaults to 0)
  artifacts:
    - skills/kata-execute-phase/SKILL.md (step 7.25 extended with brownfield auto-refresh)
  key_links:
    - Step 7.25 brownfield path reads mapper instructions from kata-map-codebase via filesystem
    - Mapper agents use haiku model (matching kata-map-codebase, not execute-phase)
    - SCAN_RAN flag prevents duplicate scan in subsequent code paths
---

<objective>
Integrate brownfield doc auto-refresh into `kata-execute-phase` SKILL.md step 7.25.

Purpose: When `detect-stale-intel.cjs` reports `brownfieldDocStale: true`, the execute-phase orchestrator spawns 4 mapper agents (same as `/kata-map-codebase`), runs `generate-intel.js`, then runs `scan-codebase.cjs`. This replaces the existing "doc gardening warning" with actual corrective action.

Output: Updated SKILL.md with brownfield auto-refresh path in step 7.25.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>
<task type="auto">
  <name>Task 1: Parse brownfield staleness fields from detect-stale-intel.cjs output</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
In step 7.25, after the existing staleness detection block that parses STALE_COUNT, STALE_PCT, and OLDEST_COMMIT from STALE_JSON, add parsing of brownfield fields:

```bash
  BROWNFIELD_STALE="false"
  BROWNFIELD_STALE=$(echo "$STALE_JSON" | node -e "try{const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));console.log(d.brownfieldDocStale===true?'true':'false')}catch{console.log('false')}" 2>/dev/null || echo "false")
  BROWNFIELD_ANALYSIS_DATE=$(echo "$STALE_JSON" | node -e "try{const d=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8'));console.log(d.brownfieldAnalysisDate||'')}catch{console.log('')}" 2>/dev/null || echo "")
```

Place this immediately after the existing `OLDEST_COMMIT` parsing block (around line 438-439 in the current file), before the unified scan decision tree.

Use the `node -e` JSON parsing pattern rather than grep for reliability (brownfieldDocStale is a boolean, not a string).
  </action>
  <verify>Read SKILL.md step 7.25 and confirm BROWNFIELD_STALE and BROWNFIELD_ANALYSIS_DATE are parsed from STALE_JSON.</verify>
  <done>Brownfield staleness fields parsed from detect-stale-intel.cjs JSON output.</done>
</task>

<task type="auto">
  <name>Task 2: Add brownfield auto-refresh path with mapper agent spawning</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
**Widen the step 7.25 gate condition.** The existing outer gate `if [ -f ".planning/intel/index.json" ]` must be widened to `if [ -f ".planning/intel/index.json" ] || [ -d ".planning/codebase" ]`. This ensures brownfield detection runs even when `index.json` doesn't exist yet (brownfield-mapped but intel never generated).

**Guard the TOTAL_FILES computation against missing index.json.** The widened gate means code can enter via the `.planning/codebase/` branch without `index.json` existing. The existing `TOTAL_FILES` line reads `index.json` directly and will throw ENOENT when the file is absent, leaving `TOTAL_FILES` empty and potentially triggering a greenfield scan before the brownfield auto-refresh block executes. Wrap the computation in try/catch with default 0:

```bash
TOTAL_FILES=$(node -e "try{const j=JSON.parse(require('fs').readFileSync('.planning/intel/index.json','utf8')); console.log(j.stats?.totalFiles ?? j.stats?.total_files ?? 0)}catch{console.log(0)}" 2>/dev/null || echo "0")
```

Insert a new brownfield auto-refresh block AFTER the brownfield field parsing (task 1) and BEFORE the unified scan decision tree. This block runs when `BROWNFIELD_STALE=true`:

```bash
  # --- Brownfield doc auto-refresh (MAINT-02 gap closure) ---
  if [ "$BROWNFIELD_STALE" = "true" ]; then
    echo "Brownfield docs stale (Analysis Date: $BROWNFIELD_ANALYSIS_DATE). Triggering auto-refresh..." >&2
```

Then add orchestrator instructions (NOT bash, this is orchestrator-level logic):

**Read mapper instructions:**
The orchestrator reads the mapper instructions file. In plugin mode: `${CLAUDE_PLUGIN_ROOT}/skills/kata-map-codebase/references/codebase-mapper-instructions.md`. In skills mode: use the Read tool to find and read `skills/kata-map-codebase/references/codebase-mapper-instructions.md` from the project root or plugin root.

Store the content as `mapper_instructions_content`.

**Spawn 4 mapper agents via Task():**
```
Task(prompt="<agent-instructions>\n{mapper_instructions_content}\n</agent-instructions>\n\nFocus area: tech\n\nMap the codebase for the tech focus area. Write STACK.md and INTEGRATIONS.md to .planning/codebase/.\n\nProject root: {project_root}", subagent_type="general-purpose", model="haiku")
Task(prompt="<agent-instructions>\n{mapper_instructions_content}\n</agent-instructions>\n\nFocus area: arch\n\nMap the codebase for the arch focus area. Write ARCHITECTURE.md and STRUCTURE.md to .planning/codebase/.\n\nProject root: {project_root}", subagent_type="general-purpose", model="haiku")
Task(prompt="<agent-instructions>\n{mapper_instructions_content}\n</agent-instructions>\n\nFocus area: quality\n\nMap the codebase for the quality focus area. Write CONVENTIONS.md and TESTING.md to .planning/codebase/.\n\nProject root: {project_root}", subagent_type="general-purpose", model="haiku")
Task(prompt="<agent-instructions>\n{mapper_instructions_content}\n</agent-instructions>\n\nFocus area: concerns\n\nMap the codebase for the concerns focus area. Write CONCERNS.md to .planning/codebase/.\n\nProject root: {project_root}", subagent_type="general-purpose", model="haiku")
```

All 4 run in parallel. Task tool blocks until complete. The orchestrator does NOT read their output (context budget preservation).

**After mapper agents complete, run intel pipeline:**

```bash
    # Run generate-intel.js (doc-derived summary)
    GENERATE_SCRIPT=""
    [ -f "scripts/generate-intel.js" ] && GENERATE_SCRIPT="scripts/generate-intel.js"
    [ -z "$GENERATE_SCRIPT" ] && GENERATE_SCRIPT=$(find skills/kata-map-codebase/scripts -name "generate-intel.js" -type f 2>/dev/null | head -1)
    if [ -n "$GENERATE_SCRIPT" ]; then
      node "$GENERATE_SCRIPT" 2>/dev/null || true
    fi

    # Run scan-codebase.cjs (full scan, overwrites code-derived artifacts)
    if [ -n "$SCAN_SCRIPT" ]; then
      node "$SCAN_SCRIPT" 2>/dev/null || true
    fi

    # Stage refreshed brownfield docs and intel artifacts
    git add .planning/codebase/ .planning/intel/ 2>/dev/null || true

    SCAN_RAN="true"
    echo "Brownfield auto-refresh complete." >&2
  fi
```

**Replace the doc gardening warning block.** The existing block at lines 477-482 that checks `STALE_HIGH` and logs a warning should be removed or guarded with `elif [ "$BROWNFIELD_STALE" != "true" ]` to avoid a redundant warning after auto-refresh. The auto-refresh already handles the >30% case.

Modify the existing doc gardening warning to only fire when brownfield auto-refresh did NOT run:

```bash
  # --- Doc gardening warning (only if auto-refresh did not run) ---
  if [ "$BROWNFIELD_STALE" != "true" ] && [ -d ".planning/codebase/" ] && [ -n "$STALE_PCT" ]; then
    ...existing warning logic...
  fi
```

Also modify the unified scan decision tree to skip when auto-refresh already ran:

Add `elif [ "$BROWNFIELD_STALE" = "true" ]; then true` (or restructure the if/elif chain) so the greenfield/staleness/incremental paths don't re-run after auto-refresh set SCAN_RAN.

Alternatively, since SCAN_RAN is already "true" after auto-refresh, the summary update block will correctly fire. The scan decision tree can be guarded with:

```bash
  if [ "$SCAN_RAN" != "true" ] && [ -n "$SCAN_SCRIPT" ]; then
    # existing scan decision tree
  fi
```

All operations are non-blocking: every node/bash call uses `|| true` or `2>/dev/null`. Failures log and continue.
  </action>
  <verify>Read SKILL.md step 7.25 and confirm: (1) brownfield auto-refresh path exists with mapper agent spawning, (2) generate-intel.js and scan-codebase.cjs run after mappers complete, (3) SCAN_RAN=true is set, (4) doc gardening warning is guarded, (5) scan decision tree skips when auto-refresh already ran.</verify>
  <done>Step 7.25 triggers brownfield re-map when stale docs detected, spawns 4 mapper agents, runs full intel pipeline, sets SCAN_RAN flag.</done>
</task>

<task type="auto">
  <name>Task 3: Add model lookup table entry for mapper agents</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
Update the model lookup table in step 0 to include the mapper agent model:

Add a row to the existing model table:

| Agent                      | quality | balanced | budget |
| -------------------------- | ------- | -------- | ------ |
| general-purpose (executor) | opus    | sonnet   | sonnet |
| general-purpose (mapper)   | haiku   | haiku    | haiku  |
| kata-verifier              | sonnet  | sonnet   | haiku  |
| kata-code-reviewer         | opus    | sonnet   | sonnet |
| kata-\*-analyzer           | sonnet  | sonnet   | haiku  |

The mapper row indicates haiku for all profiles (matching kata-map-codebase behavior). This is an informational-only change to the table; the actual model is hardcoded as "haiku" in the Task() calls in step 7.25.
  </action>
  <verify>Read the model lookup table in SKILL.md and confirm the mapper agent row exists.</verify>
  <done>Model lookup table documents mapper agent model selection.</done>
</task>
</tasks>

<verification>
1. SKILL.md step 7.25 gate checks `index.json` OR `.planning/codebase/` directory
2. BROWNFIELD_STALE initialized to "false" before JSON parsing
3. SKILL.md step 7.25 includes brownfield staleness parsing, auto-refresh path, and pipeline execution
4. Mapper agent Task() calls use haiku model with inlined mapper instructions
5. SCAN_RAN flag is correctly set after auto-refresh
6. Refreshed `.planning/codebase/` and `.planning/intel/` are git-staged before SCAN_RAN=true
7. Doc gardening warning only fires when auto-refresh did NOT run
8. All operations are non-blocking
9. Existing scan paths (greenfield, staleness, incremental) are not disrupted
</verification>

<success_criteria>
- Step 7.25 gate condition covers both index.json and .planning/codebase/ directory
- BROWNFIELD_STALE initialized to "false" before JSON parsing
- Step 7.25 reads brownfieldDocStale from JSON output
- When brownfieldDocStale=true: spawns 4 mapper agents, runs generate-intel.js, runs scan-codebase.cjs
- Refreshed brownfield docs and intel artifacts are git-staged
- SCAN_RAN=true after auto-refresh prevents duplicate scanning
- Non-blocking: all auto-refresh operations use || true
- Model lookup table includes mapper agent entry
- Existing step 7.25 behavior unchanged when brownfieldDocStale=false
</success_criteria>

<output>
After completion, create `.planning/phases/pending/58-brownfield-doc-auto-refresh/58-03-SUMMARY.md`
</output>
