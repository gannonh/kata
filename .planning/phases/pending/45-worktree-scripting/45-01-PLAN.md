---
phase: 45-worktree-scripting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-execute-phase/scripts/manage-worktree.sh
autonomous: true
source_issue: ""

must_haves:
  truths:
    - "manage-worktree.sh create produces a worktree directory with a plan-specific branch checked out"
    - "manage-worktree.sh merge fast-forward merges the plan branch to the base branch, removes worktree, and deletes branch"
    - "manage-worktree.sh list outputs active worktrees with plan associations in parseable format"
  artifacts:
    - path: "skills/kata-execute-phase/scripts/manage-worktree.sh"
      provides: "Worktree lifecycle management (create, merge, list subcommands)"
  key_links:
    - from: "manage-worktree.sh"
      to: "setup-worktrees.sh"
      via: "Assumes bare repo layout (.bare/) created by setup-worktrees.sh"
    - from: "manage-worktree.sh"
      to: "read-config.sh"
      via: "Reads worktree.enabled and pr_workflow from config"
---

<objective>
Create `manage-worktree.sh` with create/merge/list subcommands for plan-level worktree lifecycle management.

Purpose: Phase 46 will wire this script into `kata-execute-phase` so each plan executor gets an isolated worktree. This plan builds the standalone tooling that Phase 46 orchestrates.

Output: `skills/kata-execute-phase/scripts/manage-worktree.sh` (executable bash script)
</objective>

<execution_context>
<!-- Executor reads setup-worktrees.sh and read-config.sh for pattern alignment -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/completed/44-config-foundation/44-01-SUMMARY.md
@.planning/phases/completed/44-config-foundation/44-02-SUMMARY.md
@skills/kata-configure-settings/scripts/setup-worktrees.sh
@skills/kata-configure-settings/scripts/read-config.sh
@skills/kata-execute-phase/scripts/find-phase.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create manage-worktree.sh with create subcommand</name>
  <files>skills/kata-execute-phase/scripts/manage-worktree.sh</files>
  <action>
Create `skills/kata-execute-phase/scripts/manage-worktree.sh` with `set -euo pipefail`.

Script structure:
```
Usage: manage-worktree.sh <subcommand> [args]
Subcommands:
  create <phase> <plan> [base-branch]  — Create worktree for a plan
  merge  <phase> <plan> [base-branch]  — Merge plan branch back and remove worktree
  list                                 — List active plan worktrees
```

**Precondition checks (all subcommands):**
1. Verify `.bare` directory exists (bare repo layout required). If not, error with: "Error: Bare repo layout required. Run setup-worktrees.sh first."
2. Verify `worktree.enabled` is true via `read-config.sh` (sibling script in `../kata-configure-settings/scripts/read-config.sh`). If false, error with: "Error: worktree.enabled is false in config."

**`create` subcommand:**
- Args: `<phase>` (e.g., "45"), `<plan>` (e.g., "01"), optional `[base-branch]` (default: current branch from `git branch --show-current` run inside the main worktree, or "main")
- Branch name: `plan/{phase}-{plan}` (e.g., `plan/45-01`)
- Worktree path: `plan-{phase}-{plan}` relative to project root (sibling to `main/`)
- Steps:
  1. Check if worktree already exists at path. If yes, print path and exit 0 (idempotent).
  2. Create branch from base: `GIT_DIR=.bare git branch plan/{phase}-{plan} {base-branch}`
  3. Add worktree: `GIT_DIR=.bare git worktree add plan-{phase}-{plan} plan/{phase}-{plan}`
  4. Print `WORKTREE_PATH=plan-{phase}-{plan}` and `WORKTREE_BRANCH=plan/{phase}-{plan}` as key=value output (matches find-phase.sh output pattern).
- Exit codes: 0=success, 1=error

Make the file executable (`chmod +x`).

**Do NOT implement merge or list yet.** Add placeholder functions that print "Not implemented" and exit 1. Task 2 handles those.
  </action>
  <verify>
Run these checks:
```bash
# Script exists and is executable
test -x skills/kata-execute-phase/scripts/manage-worktree.sh

# Help/usage message
bash skills/kata-execute-phase/scripts/manage-worktree.sh 2>&1 | grep -q "Usage"
```
  </verify>
  <done>manage-worktree.sh exists, is executable, has create subcommand with precondition validation, and produces key=value output on success. merge/list are stubbed.</done>
</task>

<task type="auto">
  <name>Task 2: Implement merge and list subcommands</name>
  <files>skills/kata-execute-phase/scripts/manage-worktree.sh</files>
  <action>
Complete the merge and list subcommands in manage-worktree.sh.

**`merge` subcommand:**
- Args: `<phase>` (e.g., "45"), `<plan>` (e.g., "01"), optional `[base-branch]` (default: same logic as create)
- Branch name: `plan/{phase}-{plan}`
- Worktree path: `plan-{phase}-{plan}`
- Steps:
  1. Verify worktree exists at path. If not, error: "Error: No worktree at plan-{phase}-{plan}"
  2. Check for uncommitted changes in worktree: `git -C plan-{phase}-{plan} status --porcelain`. If dirty, error: "Error: Worktree has uncommitted changes. Commit or stash first."
  3. Switch to base branch in main worktree: `git -C main checkout {base-branch}`
  4. Merge plan branch into base: `git -C main merge plan/{phase}-{plan} --no-edit`. If merge fails (conflict), print error with resolution instructions and exit 1.
  5. Remove worktree: `GIT_DIR=.bare git worktree remove plan-{phase}-{plan}`
  6. Delete plan branch: `GIT_DIR=.bare git branch -d plan/{phase}-{plan}`
  7. Print `MERGED=true` and `BASE_BRANCH={base-branch}` as key=value output.
- Exit codes: 0=success, 1=error (with descriptive message)

**`list` subcommand:**
- No args required.
- Steps:
  1. Run `GIT_DIR=.bare git worktree list --porcelain`
  2. Filter to worktrees whose path matches `plan-*` pattern (exclude `main/` and bare)
  3. For each matching worktree, extract:
     - path (directory name)
     - branch (from `branch refs/heads/...` line)
     - phase and plan numbers (parsed from directory name `plan-{phase}-{plan}`)
  4. Output as table:
     ```
     WORKTREE_COUNT={N}
     plan-45-01  plan/45-01  phase=45 plan=01
     plan-45-02  plan/45-02  phase=45 plan=02
     ```
  5. If no plan worktrees exist, print `WORKTREE_COUNT=0` and exit 0.
- Exit codes: 0=success

Both subcommands follow the key=value output pattern used by find-phase.sh for easy parsing by Claude.
  </action>
  <verify>
Verify script has all three subcommands by checking function/case patterns:
```bash
grep -c "create\|merge\|list" skills/kata-execute-phase/scripts/manage-worktree.sh
```
The script should reference all three subcommands in its case statement.
  </verify>
  <done>manage-worktree.sh has create, merge, and list subcommands. create spawns worktree with plan branch. merge integrates branch back and cleans up. list shows active plan worktrees with metadata. All produce parseable key=value output.</done>
</task>

</tasks>

<verification>
- `manage-worktree.sh` exists at `skills/kata-execute-phase/scripts/manage-worktree.sh`
- Script is executable
- All three subcommands (create, merge, list) are implemented
- Script validates preconditions (bare repo, worktree.enabled)
- Output follows key=value pattern consistent with find-phase.sh
- `npm run build:plugin && npm test` passes
</verification>

<success_criteria>
- manage-worktree.sh create produces worktree directory with plan branch
- manage-worktree.sh merge integrates branch, removes worktree, deletes branch
- manage-worktree.sh list outputs active worktrees with plan associations
- Precondition checks prevent running outside bare repo layout
- All output is parseable (key=value pairs)
</success_criteria>

<output>
After completion, create `.planning/phases/pending/45-worktree-scripting/45-01-SUMMARY.md`
</output>
