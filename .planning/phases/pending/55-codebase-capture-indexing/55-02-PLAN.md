---
phase: 55-codebase-capture-indexing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/scripts/scan-codebase.test.js
  - tests/fixtures/scan-codebase/sample.js
  - tests/fixtures/scan-codebase/sample.ts
  - tests/fixtures/scan-codebase/sample.py
  - tests/fixtures/scan-codebase/sample.go
  - tests/fixtures/scan-codebase/generated.generated.ts
autonomous: true
must_haves:
  truths:
    - "Unit tests cover extractJSImports, extractJSExports, extractPyImports, extractGoImports for each language pattern"
    - "Unit tests cover classifyIdentifier for camelCase, PascalCase, snake_case, SCREAMING_SNAKE, and other"
    - "Unit tests cover detectConventions threshold edge cases: exactly 5 exports, 69% vs 71% confidence"
    - "Unit tests cover stripComments for block comments, line comments, and URL preservation"
    - "Unit tests cover mergeIndex with additions, updates, and deletions"
    - "Integration test scans fixture directory and validates index.json + conventions.json output schemas"
    - "Test fixtures include JS, TS, Python, Go files with known imports/exports"
  artifacts:
    - tests/scripts/scan-codebase.test.js
    - tests/fixtures/scan-codebase/sample.js
    - tests/fixtures/scan-codebase/sample.ts
    - tests/fixtures/scan-codebase/sample.py
    - tests/fixtures/scan-codebase/sample.go
    - tests/fixtures/scan-codebase/generated.generated.ts
  key_links:
    - "tests/scripts/scan-codebase.test.js -> imports functions from scan-codebase.cjs"
    - "tests/fixtures/scan-codebase/ -> synthetic source files with known patterns"
    - "npm run test:scripts -> runs this test file alongside existing script tests"
---

<objective>
Create comprehensive unit and integration tests for scan-codebase.cjs. Tests validate all extraction functions, convention detection thresholds, incremental merge logic, and output schema compliance.

Purpose: The scan-codebase.cjs script handles regex-based code analysis where subtle bugs in patterns cause silent data corruption. Tests pin the extraction behavior against known fixtures. Threshold edge cases (exactly 5 exports, 69% vs 71%) need explicit verification.

Output: test file + fixture files that run via `npm run test:scripts`
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/STATE.md

# Research with detailed schemas, regex patterns, and testing strategy
@.planning/phases/pending/55-codebase-capture-indexing/55-RESEARCH.md

# Existing test pattern (Node.js test runner, describe/test blocks, tmp dirs)
@tests/scripts/project-root.test.js

# Plan 01 defines the scan-codebase.cjs API (functions to test)
@.planning/phases/pending/55-codebase-capture-indexing/55-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures with known import/export patterns</name>
  <files>tests/fixtures/scan-codebase/sample.js, tests/fixtures/scan-codebase/sample.ts, tests/fixtures/scan-codebase/sample.py, tests/fixtures/scan-codebase/sample.go, tests/fixtures/scan-codebase/generated.generated.ts</files>
  <action>
Create test fixture files in tests/fixtures/scan-codebase/ with known, deterministic import/export patterns.

**tests/fixtures/scan-codebase/sample.js** — JavaScript with CJS + ESM mixed:
```javascript
// ES module imports
import express from 'express';
import { Router } from 'express';
import { hashPassword, verifyHash } from './utils/hash';
import config from '../config';

// CommonJS require
const path = require('path');
const { readFile } = require('fs');

// Dynamic import (should capture path)
const lazy = import('./lazy-module');

// Named exports
export const API_VERSION = '2.0';
export function createServer() {}
export class AppRouter {}

// Comment with fake import that should NOT be extracted
// import fakePkg from 'fake-package';
/* import anotherFake from 'another-fake'; */

// URL that should not be stripped as comment
const url = 'https://example.com/api';
```

Expected: imports.packages = ['express', 'fs', 'path'], imports.local = ['../config', './lazy-module', './utils/hash'], exports = ['API_VERSION', 'AppRouter', 'createServer']

**tests/fixtures/scan-codebase/sample.ts** — TypeScript with types and interfaces:
```typescript
import { Request, Response } from 'express';
import { UserModel } from './models/user';
import type { Config } from './types';

export interface UserService {
  findById(id: string): Promise<User>;
}

export type UserId = string;
export const DEFAULT_ROLE = 'viewer';
export enum Status {
  Active = 'active',
  Inactive = 'inactive',
}
export function validateUser(user: unknown): boolean {
  return true;
}
export default class UserController {}
```

Expected: imports.packages = ['express'], imports.local = ['./models/user', './types'], exports = ['DEFAULT_ROLE', 'Status', 'UserController', 'UserId', 'UserService', 'validateUser']

**tests/fixtures/scan-codebase/sample.py** — Python with standard patterns:
```python
import os
import sys
from pathlib import Path
from typing import Optional, List
from .models import User
from ..utils import hash_password

def create_user(name: str) -> dict:
    pass

class UserRepository:
    pass

# import fake_module  # commented out
```

Expected: imports include 'os', 'sys', 'pathlib', 'typing', '.models', '..utils'. Exports = ['UserRepository', 'create_user']

**tests/fixtures/scan-codebase/sample.go** — Go with exported functions:
```go
package main

import (
    "fmt"
    "net/http"
    "github.com/gin-gonic/gin"
)

func StartServer() {
    // ...
}

func HandleRequest(w http.ResponseWriter, r *http.Request) {
    // ...
}

func helperFunc() {
    // not exported (lowercase)
}
```

Expected: imports include 'fmt', 'net/http', 'github.com/gin-gonic/gin'. Exports = ['HandleRequest', 'StartServer'] (not helperFunc).

**tests/fixtures/scan-codebase/generated.generated.ts** — Generated file (should be excluded):
```typescript
// @generated by protoc-gen-ts
export interface GeneratedType {}
export const GENERATED_CONST = true;
```

This file should be excluded from scanning by the generated file filter.
  </action>
  <verify>
Verify all fixture files exist with expected content:
```bash
ls tests/fixtures/scan-codebase/
wc -l tests/fixtures/scan-codebase/*
```
  </verify>
  <done>
Test fixtures created with deterministic import/export patterns for JS, TS, Python, Go, and a generated file for exclusion testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit and integration tests for scan-codebase.cjs</name>
  <files>tests/scripts/scan-codebase.test.js</files>
  <action>
Create tests/scripts/scan-codebase.test.js using Node.js built-in test runner (import { test, describe } from 'node:test').

**Important:** scan-codebase.cjs is a CommonJS module. Import its exported functions using require() or dynamic import. The test file itself uses ESM (project has "type": "module"), so use `const mod = require(path)` via `createRequire` or structure the script to export functions when loaded as a module.

If scan-codebase.cjs does not export functions for direct testing, test via subprocess execution (execSync) against the fixture files. Prefer direct function imports if the script exports them; fall back to subprocess testing otherwise.

**Unit tests:**

1. **stripComments:**
   - Strips `// single line` comments
   - Strips `/* block comments */`
   - Strips multi-line block comments
   - Preserves `://` in URLs (https://example.com)
   - Preserves strings containing `//`
   - Handles empty input

2. **extractJSImports:**
   - ES module: `import X from 'pkg'` -> packages: ['pkg']
   - ES module: `import { A, B } from './local'` -> local: ['./local']
   - CJS: `const X = require('pkg')` -> packages: ['pkg']
   - CJS: `const { A } = require('./local')` -> local: ['./local']
   - Dynamic: `import('./lazy')` -> local: ['./lazy']
   - Deduplication: same import path twice -> single entry
   - Comments: import inside comment -> not extracted

3. **extractJSExports:**
   - Named: `export const X`, `export function Y`, `export class Z`
   - Types: `export type T`, `export interface I`, `export enum E`
   - Default: `export default class Name`
   - CJS: `module.exports = { a, b }`
   - Re-export: `export { X, Y } from './module'`

4. **extractPyImports and extractPyExports:**
   - `import os` -> packages: ['os']
   - `from .models import User` -> local: ['.models']
   - `def func_name():` -> exports: ['func_name']
   - `class ClassName:` -> exports: ['ClassName']
   - Commented import -> not extracted

5. **extractGoImports and extractGoExports:**
   - Single: `import "fmt"` -> packages: ['fmt']
   - Block: `import ( "fmt" "net/http" )` -> packages: ['fmt', 'net/http']
   - Exported: `func StartServer()` -> exports: ['StartServer']
   - Unexported: `func helper()` -> not in exports

6. **classifyIdentifier:**
   - 'myFunction' -> 'camelCase'
   - 'MyClass' -> 'PascalCase'
   - 'my_variable' -> 'snake_case'
   - 'MAX_RETRIES' -> 'SCREAMING_SNAKE'
   - 'A' (single char) -> 'PascalCase'
   - 'a' (single char) -> 'camelCase'
   - 'XMLParser' -> 'PascalCase'
   - 'x' -> 'camelCase'
   - '' -> 'other'

7. **detectConventions:**
   - With 4 exports (below threshold): pattern = 'insufficient_data'
   - With exactly 5 camelCase exports: pattern = 'camelCase', confidence = 1.0
   - With 7 camelCase + 3 PascalCase (70%): pattern = 'camelCase', confidence = 0.7
   - With 6 camelCase + 4 PascalCase (60%): pattern = 'mixed' (below 70% threshold)
   - Includes breakdown counts in all cases

8. **mergeIndex:**
   - Adds new file entries
   - Updates existing entries (overwrite)
   - Removes deleted file entries
   - Preserves unchanged entries

**Integration test:**

9. **Full scan of fixture directory:**
   Run `node scan-codebase.cjs` with KATA_PROJECT_ROOT pointing to a temp directory containing the fixture files and a .planning/ dir. Use a git-initialized temp dir with fixtures committed. Validate:
   - index.json has version 2, commitHash, generated timestamp
   - File entries have exports array, imports.packages, imports.local
   - conventions.json has version 2, naming section, directories section
   - generated.generated.ts is NOT in the index
   - Stats reflect correct counts

Run all tests via the existing `npm run test:scripts` command (the glob pattern `./tests/scripts/*.test.js` picks up new test files automatically).
  </action>
  <verify>
Run the tests:
```bash
node --test --test-reporter spec tests/scripts/scan-codebase.test.js
```
All tests pass. The test file follows the same pattern as tests/scripts/project-root.test.js (describe/test blocks, beforeEach/afterEach for tmp dirs, assert module).
  </verify>
  <done>
Comprehensive test suite covers all extraction functions, naming convention detection thresholds, merge logic, and schema validation. Fixture files provide deterministic test data for JS, TS, Python, Go.
  </done>
</task>

</tasks>

<verification>
1. `node --test tests/scripts/scan-codebase.test.js` passes all tests
2. Fixture files exist in tests/fixtures/scan-codebase/ with known patterns
3. Tests cover: stripComments, extractJSImports, extractJSExports, extractPyImports, extractGoImports, classifyIdentifier, detectConventions, mergeIndex
4. Threshold edge cases tested: 4 exports (insufficient), 5 exports (minimum), 69% (below), 70% (at threshold), 71% (above)
5. Integration test validates full scan output schema against fixture directory
6. `npm run test:scripts` includes scan-codebase.test.js via glob pattern
</verification>

<success_criteria>
- All extraction function tests pass with deterministic fixture data
- Naming convention threshold edge cases verified at boundaries
- Integration test validates full end-to-end scan with schema compliance
- Tests run via existing npm run test:scripts command
- Generated file exclusion tested
</success_criteria>

<output>
After completion, create `.planning/phases/pending/55-codebase-capture-indexing/55-02-SUMMARY.md`
</output>
