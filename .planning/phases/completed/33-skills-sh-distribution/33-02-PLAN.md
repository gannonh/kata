---
phase: 33-skills-sh-distribution
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - scripts/build.js
  - package.json
  - .github/workflows/plugin-release.yml
autonomous: false
must_haves:
  truths:
    - build.js produces dist/skills-sh/ with skills/ directory, README.md, and LICENSE
    - No hooks/, .claude-plugin/, CHANGELOG.md, or VERSION in skills-sh output
    - CI pipeline pushes skills-sh output to gannonh/kata-skills on release
  artifacts:
    - buildSkillsSh() function in scripts/build.js
    - npm run build:skills-sh script in package.json
    - dist/skills-sh/skills/ containing all 29 skill directories
    - dist/skills-sh/README.md generated from skill metadata
    - dist/skills-sh/LICENSE (MIT)
    - Extended plugin-release.yml with skills-sh build + push steps
  key_links:
    - scripts/build.js
    - package.json
    - .github/workflows/plugin-release.yml
---

<objective>
Add a skills-sh build target to the build system and extend CI to publish to gannonh/kata-skills.

Purpose: The skills-sh distribution channel requires a separate build output containing only skill directories, a generated README, and a LICENSE file. The CI pipeline must push this output to a dedicated GitHub repo on each release.

Output: `npm run build:skills-sh` produces dist/skills-sh/. CI pushes contents to gannonh/kata-skills on version change.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/33-skills-sh-distribution/33-RESEARCH.md
@scripts/build.js
@package.json
@.github/workflows/plugin-release.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add buildSkillsSh() to build.js + npm script + build test</name>
  <files>scripts/build.js, package.json, tests/build.test.js</files>
  <action>
**1. Add `buildSkillsSh()` function to `scripts/build.js`:**

The function:
a. Cleans `dist/skills-sh/`
b. Copies `skills/` to `dist/skills-sh/skills/` using the existing `copyDir()` function (no transformation needed since source files are already spec-compliant after Plan 01)
c. Generates `dist/skills-sh/README.md` from skill metadata:
   - Read each `skills/kata-*/SKILL.md`, extract `name` and `description` from frontmatter
   - Strip "Triggers include..." suffix from descriptions (Claude Code-specific trigger hints waste space in skills.sh card views). Use regex: `/\s*Triggers include.*$/` on the description string
   - Build a markdown document:
     ```
     # Kata Skills

     Spec-driven development framework for Claude Code.

     ## Install

     \`\`\`bash
     npx skills add gannonh/kata-skills
     \`\`\`

     ## Skills

     | Skill | Description |
     |-------|-------------|
     | kata-plan-phase | Plan detailed roadmap phases. |
     | ... | ... |

     ## License

     MIT
     ```
d. Generates `dist/skills-sh/LICENSE` with standard MIT license text (author: gannonh, year: 2026)
e. Validates: skills/ directory exists in output, README.md exists, LICENSE exists
f. Prints build summary with skill count

**2. Update `main()` in build.js:**

Accept `skills-sh` as a target alongside `plugin`:
```javascript
if (target === 'plugin' || target === 'all') {
  success = buildPlugin();
}
if (target === 'skills-sh' || target === 'all') {
  success = buildSkillsSh() && success;
}
```

Update the usage message to show both targets.

**3. Add npm script to `package.json`:**

Add `"build:skills-sh": "node scripts/build.js skills-sh"` to scripts.

**4. Add build test to `tests/build.test.js`:**

Add a new describe block `'Skills-sh build'`:

```javascript
describe('Skills-sh build', () => {
  before(() => {
    execSync('npm run build:skills-sh', { cwd: ROOT, stdio: 'pipe' });
  });

  test('creates dist/skills-sh directory', () => {
    assert.ok(fs.existsSync(path.join(ROOT, 'dist/skills-sh')));
  });

  test('includes skills directory with all skills', () => {
    const skillsDir = path.join(ROOT, 'dist/skills-sh/skills');
    assert.ok(fs.existsSync(skillsDir));
    const entries = fs.readdirSync(skillsDir).filter(e => e.startsWith('kata-'));
    assert.ok(entries.length >= 29, `Expected >= 29 skills, got ${entries.length}`);
  });

  test('includes README.md', () => {
    assert.ok(fs.existsSync(path.join(ROOT, 'dist/skills-sh/README.md')));
  });

  test('includes LICENSE', () => {
    assert.ok(fs.existsSync(path.join(ROOT, 'dist/skills-sh/LICENSE')));
  });

  test('does NOT include hooks/', () => {
    assert.ok(!fs.existsSync(path.join(ROOT, 'dist/skills-sh/hooks')));
  });

  test('does NOT include .claude-plugin/', () => {
    assert.ok(!fs.existsSync(path.join(ROOT, 'dist/skills-sh/.claude-plugin')));
  });

  test('does NOT include CHANGELOG.md', () => {
    assert.ok(!fs.existsSync(path.join(ROOT, 'dist/skills-sh/CHANGELOG.md')));
  });

  test('does NOT include VERSION', () => {
    assert.ok(!fs.existsSync(path.join(ROOT, 'dist/skills-sh/VERSION')));
  });

  test('README contains skill table', () => {
    const readme = fs.readFileSync(path.join(ROOT, 'dist/skills-sh/README.md'), 'utf8');
    assert.ok(readme.includes('kata-plan-phase'), 'README should list kata-plan-phase');
    assert.ok(readme.includes('npx skills add'), 'README should include install command');
  });

  test('README descriptions do not contain trigger phrases', () => {
    const readme = fs.readFileSync(path.join(ROOT, 'dist/skills-sh/README.md'), 'utf8');
    assert.ok(!readme.includes('Triggers include'), 'README should not have Claude Code trigger phrases');
  });
});
```

Run after implementing:
```bash
npm run build:skills-sh && npm test
```
  </action>
  <verify>
```bash
# Build skills-sh target
npm run build:skills-sh

# Verify output structure
ls dist/skills-sh/
# Should show: LICENSE  README.md  skills/

ls dist/skills-sh/skills/ | wc -l
# Should output: 29

# Verify README content
head -20 dist/skills-sh/README.md

# Verify no excluded files
test ! -d dist/skills-sh/hooks && echo "OK: no hooks"
test ! -d dist/skills-sh/.claude-plugin && echo "OK: no .claude-plugin"
test ! -f dist/skills-sh/CHANGELOG.md && echo "OK: no CHANGELOG"
test ! -f dist/skills-sh/VERSION && echo "OK: no VERSION"

# Run full test suite
npm run build:plugin && npm test
```
  </verify>
  <done>`npm run build:skills-sh` produces dist/skills-sh/ with skills/, README.md, and LICENSE. No excluded files present. All tests pass.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Build target produces skills-sh distribution. Before CI can push to gannonh/kata-skills, the repo must exist and a PAT must be configured.</what-built>
  <how-to-verify>
1. Create the `gannonh/kata-skills` GitHub repo (public, empty, no README)
2. Create or verify a Personal Access Token (PAT) scoped to push to `gannonh/kata-skills`
3. Add the token as a repository secret named `SKILLS_TOKEN` in `gannonh/kata-orchestrator` Settings > Secrets
4. Confirm: "Repo created and SKILLS_TOKEN configured"
  </how-to-verify>
  <resume-signal>Say "repo and token ready" to continue with CI pipeline extension</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Extend CI pipeline to build and push skills-sh on release</name>
  <files>.github/workflows/plugin-release.yml</files>
  <action>
Add the following steps to `.github/workflows/plugin-release.yml` AFTER the existing "Commit and push to marketplace" step. All new steps use the same `if: steps.check.outputs.should_publish == 'true'` guard.

**Step 1: Build skills.sh distribution**
```yaml
- name: Build skills.sh distribution
  if: steps.check.outputs.should_publish == 'true'
  run: node scripts/build.js skills-sh
```

**Step 2: Validate skills-sh build**
```yaml
- name: Validate skills-sh build
  if: steps.check.outputs.should_publish == 'true'
  run: |
    test -d dist/skills-sh/skills
    test -f dist/skills-sh/README.md
    test -f dist/skills-sh/LICENSE
    SKILL_COUNT=$(ls -d dist/skills-sh/skills/kata-* | wc -l)
    echo "Skills-sh build validated: $SKILL_COUNT skills"
```

**Step 3: Checkout kata-skills**
```yaml
- name: Checkout kata-skills
  if: steps.check.outputs.should_publish == 'true'
  uses: actions/checkout@v4
  with:
    repository: gannonh/kata-skills
    token: ${{ secrets.SKILLS_TOKEN }}
    path: kata-skills
```

**Step 4: Update kata-skills with built skills**
```yaml
- name: Update kata-skills with built skills
  if: steps.check.outputs.should_publish == 'true'
  run: |
    # Clean existing skills and metadata
    rm -rf kata-skills/skills kata-skills/README.md kata-skills/LICENSE

    # Copy built output
    cp -r dist/skills-sh/skills kata-skills/skills
    cp dist/skills-sh/README.md kata-skills/README.md
    cp dist/skills-sh/LICENSE kata-skills/LICENSE
```

**Step 5: Commit and push to kata-skills**
```yaml
- name: Commit and push to kata-skills
  if: steps.check.outputs.should_publish == 'true'
  working-directory: kata-skills
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git add -A
    git diff --staged --quiet || git commit -m "chore: update kata skills to v${{ steps.version.outputs.plugin_version }}"
    git push
```

This mirrors the existing marketplace push pattern (checkout > copy > commit > push) with a different repo and token.

Also update the workflow name or add a comment indicating it now handles both marketplace and skills.sh distribution.
  </action>
  <verify>
```bash
# Verify the new steps exist in the workflow
grep -c "kata-skills" .github/workflows/plugin-release.yml
# Should be >= 4 (repo name appears in checkout, update, commit steps)

grep "SKILLS_TOKEN" .github/workflows/plugin-release.yml
# Should find the token reference

grep "build:skills-sh\|build.js skills-sh" .github/workflows/plugin-release.yml
# Should find the build command

# Validate YAML syntax
python3 -c "import yaml; yaml.safe_load(open('.github/workflows/plugin-release.yml'))" 2>&1 && echo "YAML valid" || echo "YAML invalid"
```
  </verify>
  <done>CI pipeline builds skills-sh distribution and pushes to gannonh/kata-skills on release. New steps mirror existing marketplace push pattern.</done>
</task>

</tasks>

<verification>
- `npm run build:skills-sh` produces correct output structure
- `npm test` passes (including new skills-sh build tests)
- `.github/workflows/plugin-release.yml` has skills-sh build + push steps
- YAML workflow file parses without errors
- Token reference uses `secrets.SKILLS_TOKEN`
</verification>

<success_criteria>
- `dist/skills-sh/` contains skills/, README.md, LICENSE (no hooks, .claude-plugin, CHANGELOG, VERSION)
- README.md is auto-generated from skill metadata with install instructions
- README descriptions have trigger phrases stripped
- CI pipeline pushes to gannonh/kata-skills on release alongside existing marketplace push
- All existing and new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/pending/33-skills-sh-distribution/33-02-SUMMARY.md`
</output>
