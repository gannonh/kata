---
phase: 37-preferences-infrastructure--progressive-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-configure-settings/scripts/read-pref.sh
  - skills/kata-configure-settings/scripts/has-pref.sh
  - skills/kata-configure-settings/scripts/set-config.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - "read-pref.sh resolves preferences.json -> config.json -> built-in defaults -> fallback arg"
    - "has-pref.sh returns exit 0 when key exists in prefs or config, exit 1 when absent"
    - "set-config.sh atomically writes nested JSON keys with type coercion"
  artifacts:
    - skills/kata-configure-settings/scripts/read-pref.sh
    - skills/kata-configure-settings/scripts/has-pref.sh
    - skills/kata-configure-settings/scripts/set-config.sh
  key_links:
    - "DEFAULTS table in read-pref.sh is the single source of truth for all known preference keys"
    - "All scripts use heredoc node invocation to avoid bash escaping issues with !== operator"
    - "set-config.sh uses fs.renameSync for atomic writes on POSIX"
---

<objective>
Create the three accessor/utility scripts that form the foundation for Kata's preferences infrastructure.

Purpose: These scripts centralize JSON config reading, preference discovery, and atomic config writing. All subsequent skill modifications depend on these scripts existing.
Output: Three executable shell scripts in `skills/kata-configure-settings/scripts/`.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/37-preferences-infrastructure--progressive-capture/37-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create accessor and utility scripts</name>
  <files>skills/kata-configure-settings/scripts/read-pref.sh, skills/kata-configure-settings/scripts/has-pref.sh, skills/kata-configure-settings/scripts/set-config.sh</files>
  <action>
Create `skills/kata-configure-settings/scripts/` directory.

**read-pref.sh** — Usage: `read-pref.sh <key> [fallback]`
Resolution chain: preferences.json (flat key) -> config.json (nested via resolveNested) -> DEFAULTS table -> fallback arg -> empty string.

DEFAULTS table must cover ALL known preference keys:
```
'release.changelog': 'true'
'release.changelog_format': 'keep-a-changelog'
'release.version_bump': 'conventional-commits'
'docs.readme_on_milestone': 'prompt'
'docs.auto_update_files': 'README.md'
'conventions.commit_format': 'conventional'
'mode': 'yolo'
'depth': 'standard'
'model_profile': 'balanced'
'pr_workflow': 'false'
'commit_docs': 'true'
'display.statusline': 'true'
'workflow.research': 'true'
'workflow.plan_check': 'true'
'workflow.verifier': 'true'
'github.enabled': 'false'
'github.issueMode': 'never'
```

Pass KEY and FALLBACK to node via environment variables (KEY="$KEY" FALLBACK="$FALLBACK" node << 'NODE_EOF') to avoid shell interpolation. Use `process.stdout.write()` for output (no trailing newline from console.log). Handle missing/empty files gracefully via try/catch returning `{}`.

**has-pref.sh** — Usage: `has-pref.sh <key>`
Exit 0 if key exists in preferences.json (flat) OR config.json (nested via resolveNested). Exit 1 if absent from both. Does NOT check defaults table — purpose is detecting whether user has EXPRESSED a preference.

**set-config.sh** — Usage: `set-config.sh <dot.key.path> <value>`
Read existing config.json (or start with `{}`). Navigate/create nested path from dot-separated key. Type coerce: `true`/`false` -> boolean, numeric strings -> number, else string. Atomic write via temp file + `fs.renameSync`.

All scripts: `#!/usr/bin/env bash`, `set -euo pipefail`, use `node << 'NODE_EOF'` heredoc (NOT `node -e`) to avoid bash `!==` escaping issues. Make executable with `chmod +x`.

Reference the code examples in 37-RESEARCH.md for exact implementations.
  </action>
  <verify>
```bash
# Scripts exist and are executable
ls -la skills/kata-configure-settings/scripts/*.sh

# read-pref.sh returns default when no preferences/config exist
cd /tmp && mkdir -p .planning && echo '{}' > .planning/config.json && echo '{}' > .planning/preferences.json
bash /path/to/read-pref.sh mode
# Should output: yolo

bash /path/to/read-pref.sh nonexistent fallback_val
# Should output: fallback_val

# has-pref.sh returns exit 1 for missing key
bash /path/to/has-pref.sh model_profile; echo $?
# Should output: 1

# set-config.sh writes nested key
bash /path/to/set-config.sh model_profile balanced
cat .planning/config.json | grep model_profile
# Should show: "model_profile": "balanced"

# Nested key test
bash /path/to/set-config.sh workflow.research false
cat .planning/config.json | grep research
# Should show: "research": false

cd -
```
  </verify>
  <done>Three scripts exist at skills/kata-configure-settings/scripts/, are executable, and pass all verification checks. read-pref.sh resolves through the full chain. has-pref.sh correctly detects presence/absence. set-config.sh atomically writes nested keys with type coercion.</done>
</task>

<task type="auto">
  <name>Task 2: Verify scripts in realistic scenarios</name>
  <files>skills/kata-configure-settings/scripts/read-pref.sh, skills/kata-configure-settings/scripts/has-pref.sh, skills/kata-configure-settings/scripts/set-config.sh</files>
  <action>
Run integration tests against realistic config structures. Create a temp directory with:
1. Empty preferences.json (`{}`) and config.json with existing project config (mode, depth, github block, workflow block)
2. Verify read-pref.sh reads nested config keys (`github.enabled`, `workflow.research`)
3. Verify has-pref.sh returns 0 for keys in config.json, 1 for absent keys like `model_profile`
4. Verify set-config.sh preserves existing keys when adding new ones
5. Verify preferences.json overrides config.json (set a flat key in prefs, different value in config, read-pref returns prefs value)
6. Clean up temp directory

Fix any issues found. Ensure `bash -x` on each script shows no escaping problems.
  </action>
  <verify>All integration test scenarios pass. `bash -x read-pref.sh mode` shows clean execution without escaping warnings.</verify>
  <done>Scripts handle real-world config structures correctly. Preference override chain works. No bash escaping issues.</done>
</task>

</tasks>

<verification>
1. `ls -la skills/kata-configure-settings/scripts/` shows 3 executable .sh files
2. Scripts use heredoc node invocation (no `node -e`)
3. DEFAULTS table in read-pref.sh covers all 17 known keys
4. Resolution chain: preferences.json -> config.json -> defaults -> fallback
5. Atomic writes confirmed via temp file pattern in set-config.sh
</verification>

<success_criteria>
- [ ] read-pref.sh resolves through full chain and returns correct values
- [ ] has-pref.sh distinguishes expressed preferences from defaults
- [ ] set-config.sh atomically writes nested JSON with type coercion
- [ ] All scripts use heredoc pattern (no bash escaping issues)
- [ ] DEFAULTS table is comprehensive (all known keys)
- [ ] Scripts pass integration tests with realistic config
</success_criteria>

<output>
After completion, create `.planning/phases/pending/37-preferences-infrastructure--progressive-capture/37-01-SUMMARY.md`
</output>
