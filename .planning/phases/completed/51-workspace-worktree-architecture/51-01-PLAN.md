---
phase: 51-workspace-worktree-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-configure-settings/scripts/setup-worktrees.sh
  - skills/kata-configure-settings/scripts/project-root.sh
  - skills/kata-execute-phase/scripts/create-phase-branch.sh
  - skills/kata-execute-phase/scripts/manage-worktree.sh
autonomous: true
must_haves:
  truths:
    - setup-worktrees.sh creates workspace/ worktree alongside main/ during bare repo conversion
    - create-phase-branch.sh runs git checkout -b inside workspace/ instead of creating a sibling worktree
    - manage-worktree.sh merge targets workspace/ directory (not a phase worktree directory)
    - manage-worktree.sh cleanup-phase switches workspace/ back to main branch (no worktree removal)
    - project-root.sh detects workspace/.planning as a valid project root
  artifacts:
    - skills/kata-configure-settings/scripts/setup-worktrees.sh
    - skills/kata-configure-settings/scripts/project-root.sh
    - skills/kata-execute-phase/scripts/create-phase-branch.sh
    - skills/kata-execute-phase/scripts/manage-worktree.sh
  key_links:
    - setup-worktrees.sh creates the workspace/ worktree that create-phase-branch.sh operates on
    - create-phase-branch.sh outputs WORKSPACE_PATH instead of WORKTREE_PATH for orchestrator consumption
    - manage-worktree.sh merge targets the workspace/ directory passed by the orchestrator
---

<objective>
Refactor the script layer to support persistent workspace/ worktree architecture.

Purpose: Replace ephemeral phase worktrees (created as siblings to main/) with a persistent workspace/ worktree. The orchestrator and user operate from workspace/, which always tracks the active phase branch. main/ becomes read-only reference. This eliminates git -C indirection and simplifies the working directory model.

Output: Four updated bash scripts that implement the workspace worktree architecture at the script layer.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Design context from the user:

```
my-project/
  .bare/
  main/                         <- always main branch, never touched (read-only)
  workspace/                    <- persistent worktree, always the active phase branch
    plan-01-01/                  <- plan worktree forks from phase branch
    plan-01-02/
```

Key design decisions:
1. workspace/ is persistent (not ephemeral). It stays across phases. Between phases, run `git checkout` to switch branches.
2. The orchestrator runs FROM workspace/, not from main/.
3. main/ is read-only reference. Never touched during execution.
4. Plan worktrees fork from workspace/'s branch naturally.
5. The GIT_DIR_FLAG pattern from phase 50 goes away. The orchestrator IS in the workspace.

Current script implementations:
- create-phase-branch.sh: Creates a phase worktree as sibling to main/ via `GIT_DIR=../.bare git worktree add`
- manage-worktree.sh: Creates/merges plan worktrees, has cleanup-phase subcommand
- setup-worktrees.sh: Converts standard git repo to bare repo + main/ worktree layout
- project-root.sh: Detects project root via .planning/ directory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update setup-worktrees.sh to create workspace/ worktree</name>
  <files>skills/kata-configure-settings/scripts/setup-worktrees.sh</files>
  <action>
Add workspace/ worktree creation after the main/ worktree is created (step 5). The workspace/ worktree starts on the same default branch as main/ (it will be switched to phase branches during execution).

Specific changes:
1. After `GIT_DIR=.bare git worktree add main "$DEFAULT_BRANCH"` (step 5), add: `GIT_DIR=.bare git worktree add workspace "$DEFAULT_BRANCH"` — but workspace needs its own branch since two worktrees cannot share the same branch. Create a workspace tracking branch: `GIT_DIR=.bare git branch workspace-main "$DEFAULT_BRANCH" && GIT_DIR=.bare git worktree add workspace workspace-main`. Actually, simpler approach: workspace starts detached or on a workspace-init branch. The key insight: workspace/ will be switched to a phase branch during execution via `git checkout -b`. Before any phase execution, workspace is on a branch that tracks main. Use: `GIT_DIR=.bare git worktree add workspace -b workspace-base "$DEFAULT_BRANCH"`. The `-b workspace-base` creates a new branch so it doesn't conflict with main/ which is already on the default branch.

2. Add `workspace/` to .gitignore alongside `main/`.

3. Update the README.md template to describe the workspace architecture:
   - workspace/ is the persistent working directory (always the active phase branch)
   - main/ is read-only reference (always on main branch)
   - Plan worktrees appear as siblings at project root
   - Between phases, workspace/ switches branches

4. Update the setup-upstream-tracking step (step 6): also set tracking for workspace-base branch if remote exists.

5. In the cleanup step (step 7) that removes duplicate working files from project root, ensure workspace is preserved alongside main.

6. Update the output messages to tell user to cd workspace instead of cd main.

7. In step 10, also set config from workspace/ if .planning/config.json exists there.

Do NOT change the idempotency check (.bare already exists check) — that stays the same.
  </action>
  <verify>
Read the updated setup-worktrees.sh and verify:
- workspace/ worktree is created on a workspace-base branch
- .gitignore includes workspace/
- README.md template mentions workspace/ as primary working directory
- Output messages reference workspace/ instead of main/
  </verify>
  <done>setup-worktrees.sh creates both main/ (read-only) and workspace/ (active working directory) worktrees during bare repo conversion. The user is directed to workspace/ as their primary working directory.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite create-phase-branch.sh for workspace model</name>
  <files>skills/kata-execute-phase/scripts/create-phase-branch.sh</files>
  <action>
Rewrite create-phase-branch.sh to operate on workspace/ instead of creating a sibling worktree.

Current behavior: Creates a new worktree directory as sibling to main/ via `GIT_DIR=../.bare git worktree add "$WORKTREE_DIR" -b "$BRANCH" main`.

New behavior: Switch workspace/ to a new phase branch via `git -C workspace checkout -b "$BRANCH"` (or if running from inside workspace/, just `git checkout -b "$BRANCH"`).

The script runs from inside workspace/ (via project-root.sh), so it can use relative paths. But since the bare repo is at ../.bare, the script needs to handle that.

Specific changes:
1. Keep the existing milestone/phase/slug/branch-type extraction logic (steps 1-3). No changes needed there.

2. Replace step 4 (create phase worktree) with: Switch workspace to the phase branch.
   - Determine workspace path: workspace is at `$(cd .. && pwd)/workspace` (sibling to the bare repo root), OR the script is already running inside workspace/ (detected by project-root.sh).
   - If the branch already exists and workspace is already on it (resumption): output path and continue.
   - If the branch doesn't exist: `git checkout -b "$BRANCH" main` (from inside workspace/).
   - If the branch exists but workspace is on a different branch: `git checkout "$BRANCH"` (from inside workspace/).

3. Change output variables:
   - Keep BRANCH, BRANCH_TYPE, MILESTONE, PHASE_NUM, SLUG outputs unchanged.
   - Replace WORKTREE_PATH output with WORKSPACE_PATH that points to the workspace/ directory.
   - The workspace path is the project root itself (since project-root.sh cd's into workspace/).

4. Handle the case where workspace/ doesn't exist (non-worktree project or legacy setup). If no workspace/ and no ../.bare, the script is running in a standard git repo. In this case, fall back to simple `git checkout -b "$BRANCH"` in the current directory (backward compatible with non-worktree repos).

5. Resumption logic: If BRANCH already exists, check if workspace is on that branch. If yes, output and exit 0. If workspace is on a different branch, checkout the existing branch.

project-root.sh will cd the script into the project root (which is workspace/ in the bare repo layout). So `pwd` after sourcing project-root.sh gives the workspace path.
  </action>
  <verify>
Read the updated create-phase-branch.sh and verify:
- It switches workspace/ to a phase branch via git checkout -b (not worktree add)
- It outputs WORKSPACE_PATH (or equivalent) instead of WORKTREE_PATH
- Resumption handling works (branch exists, workspace already on it)
- Backward compatible with non-worktree repos (just git checkout -b in CWD)
  </verify>
  <done>create-phase-branch.sh switches workspace/ to a phase branch instead of creating a sibling worktree. Outputs WORKSPACE_PATH. Handles resumption and backward compatibility.</done>
</task>

<task type="auto">
  <name>Task 3: Update manage-worktree.sh and project-root.sh</name>
  <files>skills/kata-execute-phase/scripts/manage-worktree.sh, skills/kata-configure-settings/scripts/project-root.sh</files>
  <action>
**manage-worktree.sh changes:**

1. Update the project root detection at the top of the script. Currently it does `if [ ! -d .bare ] && [ -d ../.bare ]; then cd ..; fi`. This needs to also handle being inside workspace/. If running from workspace/ (../.bare exists), cd to parent (project root). This is the same logic, so no change needed here — but verify it works.

2. cmd_create: Plan worktrees still land at project root level as siblings. The base_branch parameter comes from the orchestrator (the phase branch that workspace/ is on). No functional change needed — plan worktrees already fork from the passed base branch. Verify the worktree path resolves correctly relative to project root.

3. cmd_merge: The merge target directory (4th arg) changes from phase worktree path to workspace/ path. The merge logic itself is unchanged — it still does `git -C "$merge_target_dir" merge "$branch_name"`. The caller just passes a different directory. No code change needed in the function itself — the orchestrator passes the correct path. Verify the function works with workspace/ as merge target.

4. cmd_cleanup_phase: Semantics change significantly. Currently removes a phase worktree directory and deletes the phase branch. New behavior: switch workspace/ back to the default branch (main/master) and delete the phase branch. No worktree directory removal.

   Replace the current cmd_cleanup_phase with:
   ```bash
   cmd_cleanup_phase() {
     local workspace_dir="${1:?Usage: manage-worktree.sh cleanup-phase <workspace-dir> <branch>}"
     local phase_branch="${2:?Usage: manage-worktree.sh cleanup-phase <workspace-dir> <branch>}"

     if [ ! -d "$workspace_dir" ]; then
       echo "Error: Workspace directory $workspace_dir not found" >&2
       exit 1
     fi

     # Check for uncommitted changes
     if [ -n "$(git -C "$workspace_dir" status --porcelain)" ]; then
       echo "Error: Workspace has uncommitted changes. Commit or stash first." >&2
       exit 1
     fi

     # Detect default branch
     local default_branch
     default_branch=$(GIT_DIR=.bare git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
     # Fallback: check if main exists, else master
     if ! GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/$default_branch" 2>/dev/null; then
       if GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/main" 2>/dev/null; then
         default_branch="main"
       elif GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/master" 2>/dev/null; then
         default_branch="master"
       fi
     fi

     # Switch workspace back to a workspace-base branch tracking the default branch
     # Cannot checkout the default branch directly (main/ worktree already has it)
     local workspace_branch="workspace-base"
     if GIT_DIR=.bare git show-ref --verify --quiet "refs/heads/$workspace_branch"; then
       # Reset workspace-base to match current default branch
       git -C "$workspace_dir" checkout "$workspace_branch" >&2
       git -C "$workspace_dir" reset --hard "$default_branch" >&2
     else
       git -C "$workspace_dir" checkout -b "$workspace_branch" "$default_branch" >&2
     fi

     # Delete phase branch
     GIT_DIR=.bare git branch -d "$phase_branch" >&2

     echo "CLEANED=true"
     echo "STATUS=cleaned"
   }
   ```

5. Update the usage/help text to reflect workspace semantics for cleanup-phase.

**project-root.sh changes:**

Add workspace/.planning detection to the priority list:
1. KATA_PROJECT_ROOT env var (unchanged)
2. CWD contains .planning/ (unchanged)
3. CWD/workspace contains .planning/ (NEW — bare repo root, prefer workspace over main)
4. CWD/main contains .planning/ (unchanged — fallback for legacy layouts)
5. Error (unchanged)

The new detection at priority 3 means: if the script is invoked from the bare repo root (where .bare/ lives), it should cd into workspace/ (not main/) to find .planning/.
  </action>
  <verify>
Read the updated manage-worktree.sh and verify:
- cmd_cleanup_phase switches workspace/ back to workspace-base branch and deletes phase branch
- cmd_cleanup_phase no longer removes a worktree directory
- Plan worktree create and merge still work (no breaking changes)

Read the updated project-root.sh and verify:
- Priority 3 checks workspace/.planning before main/.planning
- Backward compatible with existing layouts (main/.planning still works as fallback)
  </verify>
  <done>manage-worktree.sh cleanup-phase resets workspace/ to workspace-base branch. project-root.sh detects workspace/.planning at priority 3. Plan worktree create/merge unchanged.</done>
</task>

</tasks>

<verification>
- setup-worktrees.sh creates both main/ and workspace/ during conversion
- create-phase-branch.sh switches workspace/ to phase branch (no new worktree directory)
- manage-worktree.sh cleanup-phase resets workspace/ to workspace-base branch
- project-root.sh resolves to workspace/ when run from bare repo root
- All scripts maintain backward compatibility with non-worktree repos
</verification>

<success_criteria>
- [ ] setup-worktrees.sh creates workspace/ worktree on workspace-base branch
- [ ] workspace/ added to .gitignore by setup-worktrees.sh
- [ ] README template describes workspace architecture
- [ ] create-phase-branch.sh uses git checkout -b inside workspace/ (not worktree add)
- [ ] create-phase-branch.sh outputs WORKSPACE_PATH
- [ ] manage-worktree.sh cleanup-phase switches workspace/ back to workspace-base
- [ ] project-root.sh detects workspace/.planning before main/.planning
- [ ] Backward compatibility preserved for non-worktree repos
</success_criteria>

<output>
After completion, create `.planning/phases/pending/51-workspace-worktree-architecture/51-01-SUMMARY.md`
</output>
