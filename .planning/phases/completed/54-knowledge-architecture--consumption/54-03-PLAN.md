---
phase: 54-knowledge-architecture--consumption
plan: 03
type: execute
wave: 2
depends_on: [54-01]
files_modified:
  - skills/kata-execute-phase/SKILL.md
  - skills/kata-execute-phase/references/executor-instructions.md
autonomous: true
must_haves:
  truths:
    - "Executor agents receive codebase intelligence summary in their context when spawned"
    - "Executor instructions include a step to apply codebase conventions when writing code"
    - "Missing intel is gracefully handled (no error when .planning/intel/summary.md absent)"
  artifacts:
    - skills/kata-execute-phase/SKILL.md
    - skills/kata-execute-phase/references/executor-instructions.md
  key_links:
    - "kata-execute-phase SKILL.md <wave_execution> -> reads .planning/intel/summary.md"
    - "kata-execute-phase SKILL.md <wave_execution> -> inlines INTEL_BLOCK into executor Task() prompts"
    - "executor-instructions.md apply_codebase_intelligence step -> applies conventions during task execution"
---

<objective>
Wire codebase intelligence consumption into the executor workflow. The execute-phase orchestrator reads .planning/intel/summary.md and inlines it into each executor agent's prompt. The executor instructions gain a step to apply conventions from the injected summary when writing code.

Purpose: Executors write code that matches codebase conventions (naming, directory placement, import patterns, error handling) without the planner having to specify every convention in every task. Satisfies INTEG-02.

Output: Updated kata-execute-phase SKILL.md and executor-instructions.md
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Architecture research with integration point details
@.planning/research/ARCHITECTURE.md

# Current skill and instructions to modify
@skills/kata-execute-phase/SKILL.md
@skills/kata-execute-phase/references/executor-instructions.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add intel summary reading and injection to kata-execute-phase</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
Modify skills/kata-execute-phase/SKILL.md in the `<wave_execution>` section:

**Add to the "Read these files" list** (after the existing items: plan files, STATE.md, executor-instructions.md):
```
- `.planning/intel/summary.md` (if exists) â€” store as `intel_summary_content`
```

**Add INTEL_BLOCK construction** after the WORKING_DIR_BLOCK construction and before the Task() spawn calls:

```bash
# Build codebase intelligence block (empty string if no intel)
INTEL_BLOCK=""
if [ -f ".planning/intel/summary.md" ]; then
  INTEL_BLOCK="\n<codebase_intelligence>\n${intel_summary_content}\n</codebase_intelligence>"
fi
```

**Update each Task() prompt template** to include `{INTEL_BLOCK}` at the end, after `{WORKING_DIR_BLOCK}`:

Change the Task() calls from:
```
...{WORKING_DIR_BLOCK}", subagent_type=...
```
To:
```
...{WORKING_DIR_BLOCK}{INTEL_BLOCK}", subagent_type=...
```

Apply this to all three example Task() calls in the wave_execution section. The pattern is the same for each: append `{INTEL_BLOCK}` after the working directory block.

Do NOT change the Task() call signature, model selection, subagent_type, or any other orchestrator logic. Only add the read, the block construction, and the prompt injection.
  </action>
  <verify>
Read the modified SKILL.md wave_execution section. Verify:
1. `.planning/intel/summary.md` is in the read list
2. INTEL_BLOCK construction exists with conditional file check
3. All three Task() prompt templates include {INTEL_BLOCK}
4. No other changes to wave_execution logic
  </verify>
  <done>
kata-execute-phase orchestrator reads intel summary and injects it into every executor agent's prompt. Missing summary produces empty INTEL_BLOCK (no-op).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add apply_codebase_intelligence step to executor instructions</name>
  <files>skills/kata-execute-phase/references/executor-instructions.md</files>
  <action>
Modify skills/kata-execute-phase/references/executor-instructions.md:

**Add a new step** named `apply_codebase_intelligence` in the `<execution_flow>` section. Place it AFTER the `load_plan` step and BEFORE the `record_start_time` step:

```xml
<step name="apply_codebase_intelligence">
If a `<codebase_intelligence>` section exists in your prompt, apply these conventions throughout task execution:

- **Naming:** Follow the naming conventions for new files and functions (e.g., kebab-case files, camelCase functions, PascalCase components)
- **Directory placement:** Place new files in the correct directories per project structure (e.g., new components in src/components/{feature}/)
- **Import patterns:** Match existing import style (aliases like @/, ordering conventions)
- **Error handling:** Follow established error handling patterns (e.g., custom error classes, try/catch style)
- **Testing:** Match test file naming and framework conventions when writing tests
- **Avoid concerns:** Do not introduce issues listed in the Concerns section

This is guidance, not override. Plan task instructions take precedence over codebase conventions. If a task explicitly specifies a different pattern, follow the task.

If no `<codebase_intelligence>` section exists: skip this step. Execution proceeds normally without convention guidance.
</step>
```

This step is ~15 lines. It costs minimal context (~300 tokens) and provides convention awareness for the entire execution.
  </action>
  <verify>
Read the modified executor-instructions.md. Verify:
1. `apply_codebase_intelligence` step exists between `load_plan` and `record_start_time`
2. Step references `<codebase_intelligence>` section
3. Step lists concrete convention categories (naming, directories, imports, errors, testing)
4. Step clarifies plan instructions take precedence
5. Missing intel is handled (skip if absent)
  </verify>
  <done>
Executor agents apply codebase conventions when writing code. Conventions come from the inlined summary injected by the orchestrator. Plan-specific instructions override conventions when they conflict.
  </done>
</task>

</tasks>

<verification>
1. kata-execute-phase SKILL.md wave_execution reads .planning/intel/summary.md
2. kata-execute-phase SKILL.md wave_execution inlines INTEL_BLOCK into each executor prompt
3. executor-instructions.md has apply_codebase_intelligence step
4. Missing intel file causes no error in either file
</verification>

<success_criteria>
- Execute-phase orchestrator reads .planning/intel/summary.md when it exists
- Execute-phase orchestrator inlines summary into each executor agent's prompt as <codebase_intelligence>
- Executor instructions apply conventions from the inlined summary during task execution
- Plan instructions take precedence over conventions when they conflict
- Missing intel file causes no error (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/54-knowledge-architecture--consumption/54-03-SUMMARY.md`
</output>
