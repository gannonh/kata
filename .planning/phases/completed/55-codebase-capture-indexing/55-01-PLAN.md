---
phase: 55-codebase-capture-indexing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-map-codebase/scripts/scan-codebase.cjs
autonomous: true
must_haves:
  truths:
    - "scan-codebase.cjs reads source files via git ls-files and extracts imports/exports with regex"
    - "scan-codebase.cjs detects naming conventions with 5+ export minimum and 70%+ match threshold"
    - "scan-codebase.cjs detects directory purposes via name-lookup and file suffix analysis"
    - "scan-codebase.cjs produces index.json v2 with per-file lastIndexed commit hash and imports split into packages/local"
    - "scan-codebase.cjs produces conventions.json v2 with naming breakdown, directory enrichment, fileSuffixes"
    - "scan-codebase.cjs supports --incremental --since COMMIT for changed-file-only scans"
    - "scan-codebase.cjs strips comments before regex matching to avoid false positives"
  artifacts:
    - skills/kata-map-codebase/scripts/scan-codebase.cjs
  key_links:
    - "scan-codebase.cjs -> reads source files via git ls-files -> writes .planning/intel/index.json + conventions.json"
    - "incremental mode -> git diff --name-only --diff-filter=ACMR -> scans only changed files"
    - "incremental mode -> git diff --name-only --diff-filter=D -> removes deleted file entries"
---

<objective>
Create the scan-codebase.cjs script that reads actual source code files, extracts imports/exports with regex, detects naming conventions, maps directory purposes, and produces v2 index.json and conventions.json with freshness metadata.

Purpose: Phase 54 created generate-intel.js that extracts intel from Markdown prose written by mapper agents. This script fills the gap by scanning real code. The regex approach covers 90%+ of import/export patterns with zero dependencies.

Output: scan-codebase.cjs script in skills/kata-map-codebase/scripts/
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Research with detailed regex patterns, schemas, and architecture decisions
@.planning/phases/pending/55-codebase-capture-indexing/55-RESEARCH.md

# Existing intel script for project root detection pattern
@skills/kata-map-codebase/scripts/generate-intel.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scan-codebase.cjs with file discovery and import/export extraction</name>
  <files>skills/kata-map-codebase/scripts/scan-codebase.cjs</files>
  <action>
Create skills/kata-map-codebase/scripts/scan-codebase.cjs as a CommonJS Node.js script (CJS because package.json has "type": "module"). Use only Node.js built-ins (fs, path, child_process).

**Project root detection:** Use the same pattern as generate-intel.js: check KATA_PROJECT_ROOT env var, then CWD for .planning/, then CWD/main/.planning/.

**CLI interface:**
- `node scan-codebase.cjs` — full scan (all tracked files)
- `node scan-codebase.cjs --incremental --since COMMIT_HASH` — scan only files changed since commit
- `node scan-codebase.cjs --path src/` — scope full scan to directory

**Supported extensions:** .js, .mjs, .cjs, .ts, .mts, .cts, .jsx, .tsx, .py, .go, .rs

**File discovery:**
- Full scan: `git ls-files --cached --others --exclude-standard` filtered by supported extensions
- Incremental: `git diff --name-only --diff-filter=ACMR {since}..HEAD` for changed files, `git diff --name-only --diff-filter=D {since}..HEAD` for deleted files
- Optional `--path` flag: filter git ls-files output to files under that path

**Comment stripping:** Before regex matching, strip block comments (`/* ... */`) and single-line comments (`// ...`). Do NOT strip `://` (URLs). Do not strip Python `#` comments from JS/TS files. Language-aware: JS/TS get `//` and `/* */` stripping, Python gets `#` stripping.

**Import extraction (per language):**

JavaScript/TypeScript:
```javascript
// ES module imports
/import\s+(?:(\w+)\s*,?\s*)?(?:\{([^}]+)\})?\s*from\s+['"]([^'"]+)['"]/g

// CommonJS require
/require\s*\(\s*['"]([^'"]+)['"]\s*\)/g

// Dynamic import
/import\s*\(\s*['"]([^'"]+)['"]\s*\)/g
```

Python:
```javascript
/from\s+([\w.]+)\s+import\s+(.+)/g
/^import\s+([\w.]+(?:\s*,\s*[\w.]+)*)/gm
```

Go:
```javascript
/import\s+"([^"]+)"/g
/import\s*\(([\s\S]*?)\)/g
```

Rust:
```javascript
/use\s+([\w:]+)/g
```

Split imports into `packages` (non-relative paths) and `local` (paths starting with `.`). For JS/TS, also treat `@/`, `~/`, `#/` prefixed paths as local. Deduplicate and sort each array.

**Export extraction (per language):**

JavaScript/TypeScript:
```javascript
// Named exports
/export\s+(?:const|let|var|function|class|type|interface|enum)\s+(\w+)/g

// Default exports with name
/export\s+default\s+(?:function|class)\s+(\w+)/g

// Re-exports
/export\s*\{([^}]+)\}\s*(?:from\s+['"]([^'"]+)['"])?/g

// CJS module.exports
/module\.exports\s*=\s*\{([^}]+)\}/g
```

Python: extract function and class definitions
```javascript
/^(?:def|class)\s+(\w+)/gm
```

Go: capitalized function names are exports
```javascript
/^func\s+([A-Z]\w*)/gm
```

Rust: pub fn names
```javascript
/pub\s+fn\s+(\w+)/g
```

**Generated file exclusion:** Skip files matching:
- `*.generated.ts`, `*.gen.ts`, `*.generated.js`, `*.gen.js`
- `*_pb.ts`, `*_pb.js`, `*_grpc.ts`, `*_grpc.js`
- Files where any of the first 5 lines contain `@generated` or `DO NOT EDIT`

**File type and layer classification:** Reuse the same classifyType and classifyLayer functions from generate-intel.js (path-based classification).

**Per-file entry format:**
```json
{
  "exports": ["name1", "name2"],
  "imports": {
    "packages": ["express", "zod"],
    "local": ["./types", "../utils/hash"]
  },
  "type": "util",
  "layer": "shared",
  "lastIndexed": "abc123f",
  "indexedAt": "2026-02-15T22:34:31Z"
}
```

**index.json v2 output:**
```json
{
  "version": 2,
  "generated": "ISO-8601",
  "source": "code-scan",
  "commitHash": "abc123f",
  "files": { ... },
  "stats": {
    "totalFiles": 42,
    "byType": {},
    "byLayer": {},
    "byExtension": {}
  }
}
```

Get current commit hash via `git rev-parse --short HEAD`.

**Incremental merge:** When `--incremental`, read existing .planning/intel/index.json, remove entries for deleted files, add/update entries for changed files, rewrite the file. If existing index.json does not exist or has version !== 2, fall back to full scan.
  </action>
  <verify>
Run the script against the current codebase:
```bash
node skills/kata-map-codebase/scripts/scan-codebase.cjs
cat .planning/intel/index.json | node -e "const j=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('version:', j.version, 'files:', Object.keys(j.files).length)"
```
Verify: index.json has version 2 and contains file entries. Verify: each file entry has exports array, imports object with packages/local, lastIndexed, indexedAt.
  </verify>
  <done>
scan-codebase.cjs produces index.json v2 with per-file imports/exports, type, layer, and freshness metadata. Comment stripping prevents false positives. Imports split into packages/local.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add naming convention detection and directory purpose mapping</name>
  <files>skills/kata-map-codebase/scripts/scan-codebase.cjs</files>
  <action>
Extend scan-codebase.cjs with naming convention detection and directory purpose mapping. These functions produce conventions.json v2.

**Naming convention detection (CAP-03):**

Classify each exported identifier name:
```javascript
function classifyIdentifier(name) {
  if (/^[A-Z][A-Z0-9_]+$/.test(name) && name.includes('_')) return 'SCREAMING_SNAKE';
  if (/^[A-Z][a-zA-Z0-9]*$/.test(name)) return 'PascalCase';
  if (/^[a-z][a-zA-Z0-9]*$/.test(name)) return 'camelCase';
  if (/^[a-z][a-z0-9]*(?:_[a-z0-9]+)+$/.test(name)) return 'snake_case';
  return 'other';
}
```

Detection logic:
1. Collect ALL exported identifiers from the scanned file index
2. If fewer than 5 total exports: report `{ pattern: "insufficient_data", confidence: 0, sampleSize: N }`
3. Count each classification
4. Find dominant pattern (highest count)
5. Calculate confidence = dominant_count / total
6. If confidence < 0.70: report `{ pattern: "mixed", confidence: N, sampleSize: M, breakdown: counts }`
7. Otherwise: report dominant pattern with confidence, sampleSize, and full breakdown

**Directory purpose detection (CAP-04):**

Two methods combined:

1. **Name-based lookup table:**
```javascript
const DIR_PURPOSES = {
  'components': 'UI components',
  'hooks': 'React hooks',
  'utils': 'Utility functions',
  'lib': 'Shared library code',
  'services': 'Service layer',
  'api': 'API endpoints',
  'routes': 'Route definitions',
  'types': 'Type definitions',
  'models': 'Data models',
  'tests': 'Test files',
  '__tests__': 'Test files',
  'middleware': 'Middleware',
  'config': 'Configuration',
  'scripts': 'Build/utility scripts',
  'pages': 'Page components',
  'layouts': 'Layout components',
  'store': 'State management',
  'styles': 'Stylesheets',
  'assets': 'Static assets',
  'public': 'Public assets',
  'skills': 'Kata skills',
  'references': 'Skill reference docs',
};
```

2. **Structural analysis (suffix patterns):**
Group scanned files by parent directory. For each directory with 3+ files, detect dominant file suffix. Record fileCount and dominantSuffix.

Combine: structural analysis enriches name-based entries. Directories not in the lookup table get purpose from suffix analysis if dominant suffix has a known mapping (e.g., `.test.ts` maps to "test files"). detectedBy field: "name-lookup", "suffix-analysis", or "both".

**File suffix pattern detection:**
Scan all files, collect compound suffixes (.test.ts, .spec.tsx, .service.ts, .controller.ts, .model.ts, .entity.ts, .hook.ts, .stories.tsx, .module.ts). Report as fileSuffixes map with purpose and count.

Known suffix-to-purpose mappings:
- `.test.ts`, `.test.tsx`, `.test.js`, `.test.jsx`, `.spec.ts`, `.spec.tsx`, `.spec.js`, `.spec.jsx` -> "test files"
- `.service.ts`, `.service.js` -> "service layer"
- `.controller.ts`, `.controller.js` -> "controller layer"
- `.model.ts`, `.model.js`, `.entity.ts`, `.entity.js` -> "data model"
- `.hook.ts`, `.hook.js` -> "React hooks"
- `.component.tsx`, `.component.jsx` -> "UI components"
- `.stories.tsx`, `.stories.jsx`, `.stories.ts`, `.stories.js` -> "Storybook stories"
- `.module.ts`, `.module.js` -> "NestJS/Angular module"

**conventions.json v2 output:**
```json
{
  "version": 2,
  "generated": "ISO-8601",
  "commitHash": "abc123f",
  "naming": {
    "exports": {
      "pattern": "camelCase",
      "confidence": 0.85,
      "sampleSize": 42,
      "breakdown": {
        "camelCase": 36,
        "PascalCase": 4,
        "other": 2
      }
    }
  },
  "directories": {
    "components/": {
      "purpose": "UI components",
      "detectedBy": "name-lookup",
      "fileCount": 15,
      "dominantSuffix": ".tsx"
    }
  },
  "fileSuffixes": {
    ".test.ts": { "purpose": "test files", "count": 23 },
    ".service.ts": { "purpose": "service layer", "count": 5 }
  }
}
```

Wire both functions into the main flow: after building the file index, run detectConventions() and detectDirectories() to build conventions.json. Write both index.json and conventions.json to .planning/intel/.

For incremental mode: rebuild conventions from the full merged index (conventions depend on all exports, not just changed files). Read the merged index after incremental merge, then recompute conventions.
  </action>
  <verify>
Run scan-codebase.cjs and check conventions output:
```bash
node skills/kata-map-codebase/scripts/scan-codebase.cjs
cat .planning/intel/conventions.json | node -e "const j=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('version:', j.version, 'naming:', j.naming.exports.pattern, 'confidence:', j.naming.exports.confidence, 'dirs:', Object.keys(j.directories).length)"
```
Verify: conventions.json has version 2, naming.exports has pattern/confidence/sampleSize/breakdown, directories entries have purpose/detectedBy/fileCount.
  </verify>
  <done>
scan-codebase.cjs detects naming conventions with 5+ threshold and 70%+ confidence. Directory purposes detected via name-lookup and suffix analysis. File suffix patterns mapped. conventions.json v2 written with full breakdown data.
  </done>
</task>

</tasks>

<verification>
1. `node skills/kata-map-codebase/scripts/scan-codebase.cjs` exits 0 and produces .planning/intel/index.json + conventions.json
2. index.json has version 2, commitHash, per-file lastIndexed/indexedAt, imports split into packages/local
3. conventions.json has version 2, naming.exports with pattern/confidence/sampleSize/breakdown
4. conventions.json has directories with purpose/detectedBy/fileCount and fileSuffixes section
5. `node scan-codebase.cjs --incremental --since HEAD~1` merges into existing index.json
6. Comment stripping prevents false positives (imports inside comments not extracted)
7. Generated files excluded from scan
</verification>

<success_criteria>
- scan-codebase.cjs scans real source files via git ls-files and extracts imports/exports with regex
- Naming convention detection fires at 5+ exports with 70%+ match rate (CAP-03)
- Directory purposes and file suffix patterns detected from codebase structure (CAP-04)
- index.json v2 contains per-file dependency graph with packages/local import split (CAP-05)
- All entries include lastIndexed commit hash and indexedAt timestamp (MAINT-04)
- Incremental mode scans only changed files and handles deleted file cleanup
- Script uses only Node.js built-ins, is CJS format, handles project root detection
</success_criteria>

<output>
After completion, create `.planning/phases/pending/55-codebase-capture-indexing/55-01-SUMMARY.md`
</output>
