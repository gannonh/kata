---
phase: 55-codebase-capture-indexing
plan: 03
type: execute
wave: 2
depends_on: [55-01]
files_modified:
  - skills/kata-map-codebase/scripts/generate-intel.js
  - skills/kata-map-codebase/SKILL.md
  - skills/kata-execute-phase/SKILL.md
autonomous: true
must_haves:
  truths:
    - "generate-intel.js output includes commitHash top-level in index.json and conventions.json"
    - "kata-map-codebase runs scan-codebase.cjs after generate-intel.js in step 5.6"
    - "kata-execute-phase runs incremental scan-codebase.cjs in step 7.25 after verification"
    - "Incremental scan is non-blocking: failure does not halt phase execution"
    - "Incremental scan uses first commit hash from plan execution as --since argument"
  artifacts:
    - skills/kata-map-codebase/scripts/generate-intel.js
    - skills/kata-map-codebase/SKILL.md
    - skills/kata-execute-phase/SKILL.md
  key_links:
    - "kata-map-codebase SKILL.md step 5.6 -> node scripts/scan-codebase.cjs"
    - "kata-execute-phase SKILL.md step 7.25 -> node scripts/scan-codebase.cjs --incremental --since COMMIT"
    - "generate-intel.js -> adds commitHash to JSON outputs"
---

<objective>
Add freshness metadata to generate-intel.js outputs, wire scan-codebase.cjs into kata-map-codebase as a full-scan step, and wire incremental scanning into kata-execute-phase as a post-verification step.

Purpose: Without integration, the scan script exists but never runs. This plan connects it to both entry points: full scan during brownfield mapping (kata-map-codebase) and incremental updates during phase execution (kata-execute-phase, CAP-02). The generate-intel.js freshness update ensures all intel artifacts carry version and commit metadata (MAINT-04).

Output: Updated generate-intel.js, kata-map-codebase/SKILL.md, kata-execute-phase/SKILL.md
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

# Research with integration point details
@.planning/phases/pending/55-codebase-capture-indexing/55-RESEARCH.md

# Files to modify
@skills/kata-map-codebase/scripts/generate-intel.js
@skills/kata-map-codebase/SKILL.md
@skills/kata-execute-phase/SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add freshness metadata to generate-intel.js outputs</name>
  <files>skills/kata-map-codebase/scripts/generate-intel.js</files>
  <action>
Modify generate-intel.js to add freshness metadata to its JSON outputs.

**Changes to index.json output (buildIndex function):**
Add a `commitHash` field at the top level. Get the current short commit hash via:
```javascript
import { execSync } from 'node:child_process';

function getCurrentCommitHash(projectRoot) {
  try {
    return execSync('git rev-parse --short HEAD', {
      cwd: projectRoot,
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe'],
    }).trim();
  } catch {
    return 'unknown';
  }
}
```

The function already imports `fileURLToPath` from `node:url`. Add `execSync` to the existing imports from `node:child_process` (add the import since it does not currently exist).

Update buildIndex to accept projectRoot and include commitHash:
```javascript
{
  version: 1,
  generated: generatedIso,
  source: SOURCE_LABEL,
  commitHash: getCurrentCommitHash(projectRoot),  // NEW
  files: { ... },
  stats: { ... }
}
```

**Changes to conventions.json output (buildConventions function):**
Add commitHash at the same level:
```javascript
{
  version: 1,
  generated: generatedIso,
  commitHash: getCurrentCommitHash(projectRoot),  // NEW
  naming: { ... },
  directories: { ... },
  patterns: { ... },
  confidence: '...'
}
```

**Keep version: 1** for generate-intel.js outputs. It produces doc-derived data. scan-codebase.cjs produces code-derived data with version: 2. They serve different sources and consumers can distinguish by version number.

Pass projectRoot through to both build functions. The main() function already resolves projectRoot via resolveProjectRoot().

Test: run `node skills/kata-map-codebase/scripts/generate-intel.js` and verify both JSON files now include a `commitHash` field.
  </action>
  <verify>
```bash
node skills/kata-map-codebase/scripts/generate-intel.js
node -e "const j=JSON.parse(require('fs').readFileSync('.planning/intel/index.json','utf8')); console.log('commitHash:', j.commitHash)"
node -e "const j=JSON.parse(require('fs').readFileSync('.planning/intel/conventions.json','utf8')); console.log('commitHash:', j.commitHash)"
```
Verify: both files have a commitHash field that is a non-empty string.
  </verify>
  <done>
generate-intel.js adds commitHash to both index.json and conventions.json outputs. Git command failure degrades gracefully to 'unknown'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire scan-codebase.cjs into kata-map-codebase and kata-execute-phase</name>
  <files>skills/kata-map-codebase/SKILL.md, skills/kata-execute-phase/SKILL.md</files>
  <action>
**Update kata-map-codebase/SKILL.md:**

Add step 5.6 after the existing step 5.5 (generate-intel.js) and before step 6 (commit). Insert this new step:

```
5.6. Scan source code for structured index
   Run the code scanner to produce code-derived index.json and conventions.json:
   ```bash
   node scripts/scan-codebase.cjs
   ```
   This overwrites the doc-derived index.json and conventions.json from step 5.5 with code-derived data (version 2 schema with per-file imports/exports, naming detection, directory purposes).
   If the script fails, show the error to the user and continue (non-blocking).
   Verify code-scan artifacts:
   ```bash
   node -e "const j=JSON.parse(require('fs').readFileSync('.planning/intel/index.json','utf8')); console.log('index version:', j.version, 'files:', Object.keys(j.files).length)"
   ```
```

Update the objective output line to mention code-scanned intel:
- Current: `Output: .planning/codebase/ folder with 7 structured documents, plus .planning/intel/ with compressed agent-readable artifacts.`
- New: `Output: .planning/codebase/ folder with 7 structured documents, plus .planning/intel/ with compressed agent-readable artifacts (doc-derived summary + code-scanned index and conventions).`

Update step 6 (commit) to ensure .planning/intel/ is staged (it already should be from step 5.5 update, but verify the git add includes it).

**Update kata-execute-phase/SKILL.md:**

Add step 7.25 between step 7 (verification) and step 7.5 (validate and move to completed). Insert this new step:

```
7.25. **Update codebase index (incremental scan)**

If `.planning/intel/index.json` exists, run an incremental codebase scan to capture changes from this phase's execution. This keeps the index fresh as code evolves.

```bash
if [ -f ".planning/intel/index.json" ]; then
  # Get the earliest commit from this phase execution
  # Use the activation commit as the baseline
  PHASE_START_COMMIT=$(git log --oneline --all --grep="activate phase" --grep="${PHASE_NUM}" --all-match --format="%H" | tail -1)

  if [ -n "$PHASE_START_COMMIT" ]; then
    node "$(dirname "$(find skills/kata-map-codebase/scripts -name 'scan-codebase.cjs' 2>/dev/null | head -1)")/scan-codebase.cjs" --incremental --since "$PHASE_START_COMMIT" 2>/dev/null || true
  fi
fi
```

Non-blocking: if the scan fails or intel does not exist, continue silently. The scan is an optional enhancement. The `|| true` ensures the step never blocks phase completion.

Locate the script via find because the executor may run from workspace/ or project root. The find-based path handles both locations.
```

Place step 7.25 immediately after the step 7 verification block and before the step 7.5 completion validation block.

Do NOT modify any other steps. Do not change wave execution, Task() spawning, or any other orchestrator logic.
  </action>
  <verify>
Read both updated SKILL.md files:
```bash
grep -n "5.6\|scan-codebase" skills/kata-map-codebase/SKILL.md
grep -n "7.25\|scan-codebase\|incremental" skills/kata-execute-phase/SKILL.md
```
Verify:
1. kata-map-codebase SKILL.md has step 5.6 running scan-codebase.cjs after step 5.5
2. kata-execute-phase SKILL.md has step 7.25 running incremental scan after verification
3. Both steps are non-blocking (failure does not halt workflow)
4. No other steps modified
  </verify>
  <done>
scan-codebase.cjs wired into both entry points. Full scan runs during kata-map-codebase after doc-based intel generation. Incremental scan runs during kata-execute-phase after verification. Both are non-blocking.
  </done>
</task>

</tasks>

<verification>
1. generate-intel.js outputs include commitHash in both index.json and conventions.json
2. kata-map-codebase SKILL.md has step 5.6 for full code scan
3. kata-execute-phase SKILL.md has step 7.25 for incremental scan
4. Both integration points are non-blocking (failure does not halt workflow)
5. `node skills/kata-map-codebase/scripts/generate-intel.js` still produces valid artifacts
6. No other SKILL.md steps modified
</verification>

<success_criteria>
- generate-intel.js adds commitHash to JSON outputs (MAINT-04)
- kata-map-codebase runs scan-codebase.cjs for full code scan after doc-based intel
- kata-execute-phase runs incremental scan after verification (CAP-02)
- Both integration points gracefully handle script failure
- Incremental scan uses phase activation commit as baseline
</success_criteria>

<output>
After completion, create `.planning/phases/pending/55-codebase-capture-indexing/55-03-SUMMARY.md`
</output>
