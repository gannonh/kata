---
phase: 50-orchestrator-phase-worktree-lifecycle
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-execute-phase/references/phase-execute.md
autonomous: true

must_haves:
  truths:
    - "worktree_lifecycle step documents phase worktree creation before any plan execution"
    - "worktree_lifecycle create step passes base_branch explicitly to manage-worktree.sh"
    - "worktree_lifecycle merge step passes base_branch and merge_target_dir to manage-worktree.sh"
    - "execute_waves step references PR_WORKFLOW-conditional working directory logic"
    - "Three working directory cases documented: plan worktree, phase worktree, no worktree"
    - "Phase completion section documents PR from phase branch and cleanup-phase call"
  artifacts:
    - path: "skills/kata-execute-phase/references/phase-execute.md"
      provides: "Updated reference with phase worktree lifecycle integrated into execution workflow"
  key_links:
    - from: "worktree_lifecycle step"
      to: "create-phase-branch.sh"
      via: "Phase worktree creation before plan execution"
    - from: "worktree_lifecycle merge step"
      to: "manage-worktree.sh merge"
      via: "Explicit base_branch and merge_target_dir args"
    - from: "execute_waves step"
      to: "SKILL.md wave_execution"
      via: "Three-case working directory injection"
---

<objective>
Update phase-execute.md reference to reflect the phase worktree architecture. The worktree_lifecycle step gains phase worktree creation as the first operation, plan create/merge calls pass explicit phase branch args, and execute_waves documents the three-case working directory injection.

Purpose: Keeps the reference doc consistent with SKILL.md changes (Plan 01). Executor agents and future developers read this file to understand the worktree lifecycle.
Output: Updated phase-execute.md with phase worktree lifecycle and three-case working directory logic.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/refactor-worktree-phases.md
@skills/kata-execute-phase/references/phase-execute.md
@skills/kata-execute-phase/scripts/create-phase-branch.sh
@skills/kata-execute-phase/scripts/manage-worktree.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite worktree_lifecycle step for phase worktree architecture</name>
  <files>skills/kata-execute-phase/references/phase-execute.md</files>
  <action>
Rewrite the `<step name="worktree_lifecycle">` section in phase-execute.md. The current content describes plan-level worktree lifecycle only (detect, create per plan, inject path, merge per plan, cleanup). Replace with the two-tier lifecycle: phase worktree first, then plan worktrees within.

New structure for worktree_lifecycle step:

```xml
<step name="worktree_lifecycle">
Manage the two-tier worktree lifecycle: phase worktrees (always when PR_WORKFLOW=true) and plan worktrees (when worktree.enabled=true).

**0. Detection:**

```bash
WORKTREE_ENABLED=$(bash scripts/read-config.sh "worktree.enabled" "false")
PR_WORKFLOW=$(bash scripts/read-config.sh "pr_workflow" "false")
```

Store both variables. When `PR_WORKFLOW=false`, skip all worktree operations.

**1. Create phase worktree (before any plan execution):**

```bash
if [ "$PR_WORKFLOW" = "true" ]; then
  eval "$(bash scripts/create-phase-branch.sh "$PHASE_DIR")"
  PHASE_WORKTREE_PATH=$WORKTREE_PATH
  PHASE_BRANCH=$BRANCH
fi
```

Creates a worktree directory as a sibling to `main/` (e.g., `feat-v1.11-50-orchestrator-lifecycle/`). The `main/` directory stays on the `main` branch. All subsequent work happens in the phase worktree or plan worktrees forked from it.

**2. Create plan worktrees (per plan, before agent spawn):**

Only when both `PR_WORKFLOW=true` AND `WORKTREE_ENABLED=true`:

```bash
if [ "$WORKTREE_ENABLED" = "true" ] && [ "$PR_WORKFLOW" = "true" ]; then
  eval "$(bash scripts/manage-worktree.sh create "$PHASE" "$PLAN" "$PHASE_BRANCH")"
  # WORKTREE_PATH now set (e.g., "plan-50-01")
fi
```

The third arg (`$PHASE_BRANCH`) tells manage-worktree.sh to fork from the phase branch, not from main.

**3. Inject working directory into agent prompt:**

Three cases based on config:

| PR_WORKFLOW | WORKTREE_ENABLED | Working Directory | Why |
|-------------|------------------|-------------------|-----|
| true | true | Plan worktree path | Agent works in isolated plan branch |
| true | false | Phase worktree path | Agent works directly in phase branch |
| false | (any) | (omitted) | Agent works in project root (legacy behavior) |

Add to each executor agent's Task() prompt:

```xml
<working_directory>{resolved_path}</working_directory>
```

The executor agent reads this block and cd's into the path before any file or git operations.

**4. Merge plan worktrees (per plan, after wave completes):**

Only when both `PR_WORKFLOW=true` AND `WORKTREE_ENABLED=true`:

```bash
if [ "$WORKTREE_ENABLED" = "true" ] && [ "$PR_WORKFLOW" = "true" ]; then
  bash scripts/manage-worktree.sh merge "$PHASE" "$PLAN" "$PHASE_BRANCH" "$PHASE_WORKTREE_PATH"
fi
```

The third arg (`$PHASE_BRANCH`) is the base branch. The fourth arg (`$PHASE_WORKTREE_PATH`) is the merge target directory. Plan branches merge into the phase worktree, not into `main/`.

**5. Phase completion (after all waves):**

When `PR_WORKFLOW=true`: Push the phase branch and create a PR against main.

```bash
git -C "$PHASE_WORKTREE_PATH" push -u origin "$PHASE_BRANCH"
gh pr create --draft --head "$PHASE_BRANCH" --base main ...
```

When `PR_WORKFLOW=false`: No phase worktree exists. Standard behavior.

**6. Cleanup (after PR merge):**

After the PR is merged (or local merge completed):

```bash
bash scripts/manage-worktree.sh cleanup-phase "$PHASE_WORKTREE_PATH" "$PHASE_BRANCH"
```

Removes the phase worktree directory and deletes the phase branch.

**7. Cleanup on failure:**

If an agent fails, its worktree remains on disk for debugging. Plan worktrees stay for inspection. The phase worktree also remains. The user can:
- Fix the issue and resume execution
- Discard plan work with `git worktree remove plan-{phase}-{plan}`
- Discard entire phase with `manage-worktree.sh cleanup-phase`
</step>
```

Preserve the XML step structure. Do NOT change step name attribute.

**Important:** The step describes the overall lifecycle. Individual call sites in execute_waves reference this step. Keep it as a reference, not executable code.
  </action>
  <verify>
Read phase-execute.md worktree_lifecycle step and confirm:
1. Phase worktree creation is step 1 (before any plan execution)
2. Plan worktree creation passes PHASE_BRANCH as third arg
3. Plan worktree merge passes PHASE_BRANCH and PHASE_WORKTREE_PATH
4. Three-case working directory table present
5. Phase completion describes push from phase worktree
6. Cleanup-phase documented for post-merge
7. `npm run build:plugin` succeeds
  </verify>
  <done>worktree_lifecycle step documents complete two-tier lifecycle with phase worktree as foundation.</done>
</task>

<task type="auto">
  <name>Task 2: Update execute_waves and worktree_context for phase worktree logic</name>
  <files>skills/kata-execute-phase/references/phase-execute.md</files>
  <action>
Update three sections in phase-execute.md for consistency with the new worktree_lifecycle:

**1. execute_waves step:**

In the `<step name="execute_waves">` section, find the text:

```
**Worktree mode:** If `WORKTREE_ENABLED=true`, see `worktree_lifecycle` step for pre-spawn (create worktree) and post-wave (merge worktree) operations that wrap each wave.
```

Replace with:

```
**Worktree mode:** If `PR_WORKFLOW=true`, see `worktree_lifecycle` step for phase worktree creation (before any waves) and plan worktree create/merge operations (per wave when `WORKTREE_ENABLED=true`). When `PR_WORKFLOW=true` and `WORKTREE_ENABLED=false`, agents work directly in the phase worktree.
```

**2. worktree_context inside context_efficiency:**

Find the `<worktree_context>` block and update it. Current text references only plan worktrees. Update to mention phase worktree creation overhead:

```xml
<worktree_context>
Phase worktree creation adds one script call at startup (create-phase-branch.sh). Plan worktree isolation (when worktree.enabled=true) adds per-wave manage-worktree.sh create and merge calls. Each plan agent receives a clean working directory on an isolated git branch. The orchestrator tracks PHASE_WORKTREE_PATH and PHASE_BRANCH (phase-level) plus WORKTREE_PATH per plan (plan-level). Total overhead: approximately 2-3% of orchestrator context.
</worktree_context>
```

**3. aggregate_results step:**

No changes needed. The step reads SUMMARYs from the phase directory which is the same path regardless of worktree layout.

**4. update_roadmap step:**

Find the git commit block in the update_roadmap step:

```bash
git add .planning/ROADMAP.md .planning/STATE.md .planning/phases/{phase_dir}/*-VERIFICATION.md
```

Add a note that when PR_WORKFLOW=true, these git operations execute in the phase worktree (which has its own copy of .planning/):

```
**When PR_WORKFLOW=true:** Git add/commit operations in this step execute in the phase worktree directory. The phase worktree contains the same directory structure as main/, including .planning/.
```

**Do NOT change:** load_project_state, validate_phase, discover_plans, group_by_wave, checkpoint_handling, run_test_suite, verify_phase_goal, offer_next, failure_handling, or resumption sections.
  </action>
  <verify>
Read phase-execute.md and confirm:
1. execute_waves references PR_WORKFLOW condition
2. worktree_context mentions phase worktree creation overhead
3. update_roadmap has phase worktree note
4. `npm run build:plugin` succeeds
5. `npm test` passes
  </verify>
  <done>execute_waves, worktree_context, and update_roadmap sections consistent with phase worktree architecture.</done>
</task>

</tasks>

<verification>
- `npm run build:plugin` succeeds
- `npm test` passes
- phase-execute.md worktree_lifecycle describes two-tier lifecycle (phase + plan)
- phase-execute.md execute_waves references PR_WORKFLOW condition
- phase-execute.md contains three-case working directory table
- No references to `git -C main` for merge operations in worktree_lifecycle
</verification>

<success_criteria>
- phase-execute.md reference consistent with SKILL.md orchestrator changes
- Two-tier worktree lifecycle documented: phase worktree first, plan worktrees within
- Three working directory cases documented with clear decision table
- Phase completion and cleanup paths documented
</success_criteria>

<output>
After completion, create `.planning/phases/50-orchestrator-phase-worktree-lifecycle/50-02-SUMMARY.md`
</output>
