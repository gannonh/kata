---
phase: 56-greenfield-integration
plan: 02
type: execute
wave: 2
depends_on: [56-01]
files_modified:
  - skills/kata-execute-phase/scripts/update-intel-summary.cjs
  - skills/kata-execute-phase/SKILL.md
autonomous: true
must_haves:
  truths:
    - First phase execution on a greenfield project populates index.json from generated code
    - After full scan, summary.md contains file counts, extensions, layers, and convention data derived from code
    - Subsequent phase executions run incremental scans (existing behavior preserved)
    - Projects without .planning/intel/ are unaffected (skip behavior preserved)
    - The summary update script works from index.json + conventions.json only (no .planning/codebase/ dependency)
  artifacts:
    - skills/kata-execute-phase/scripts/update-intel-summary.cjs
    - skills/kata-execute-phase/SKILL.md (modified step 7.25)
  key_links:
    - Step 7.25 reads stats.totalFiles from index.json to decide full vs incremental scan
    - Full scan (totalFiles==0) runs scan-codebase.cjs without --incremental flag
    - update-intel-summary.cjs runs after any scan that changes index.json
    - summary.md output matches the section schema consumed by planners and executors
---

<objective>
Create the summary update script and modify kata-execute-phase step 7.25 to use smart gate logic: full scan for greenfield first population, incremental for subsequent phases.

Purpose: After plan 01 scaffolds empty intel, the gate in step 7.25 must detect `totalFiles == 0` and trigger a full code scan instead of incremental. After the scan populates index.json and conventions.json, summary.md must also be updated so planners/executors get useful context (not stale scaffold text).

Output: New `update-intel-summary.cjs` script + modified step 7.25 in `kata-execute-phase` SKILL.md
</objective>

<execution_context>
<!-- Executor agent has built-in instructions -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/56-greenfield-integration/56-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update-intel-summary.cjs script</name>
  <files>skills/kata-execute-phase/scripts/update-intel-summary.cjs</files>
  <action>
Create a Node.js CJS script at `skills/kata-execute-phase/scripts/update-intel-summary.cjs` that regenerates `summary.md` from `index.json` + `conventions.json` data.

This script is the greenfield alternative to `generate-intel.js` (which requires `.planning/codebase/` docs from mapper agents). It produces a lighter summary from code-scan data only.

The script must:

1. Use the same `resolveProjectRoot()` pattern from scan-codebase.cjs
2. Read `.planning/intel/index.json` and `.planning/intel/conventions.json`
3. If `index.json` has `stats.totalFiles == 0`, exit silently (nothing to summarize)
4. If `.planning/codebase/` directory exists, exit silently (generate-intel.js handles this case; do not overwrite its richer output)
5. Generate summary.md with this structure:

```markdown
# Codebase Intelligence Summary

Generated: YYYY-MM-DD | Source: code-scan (greenfield)

## Stack
- {totalFiles} source files indexed
- {ext}: {count} files  (for each extension in stats.byExtension)

## Architecture
- {layer}: {count} files  (for each layer in stats.byLayer)

## Conventions
- Export naming: {pattern} (confidence: {confidence})
- {dir} â€” {purpose}  (for each directory in conventions.directories, max 10)

## Key Patterns
- File types: {type}: {count}  (for each type in stats.byType)

## Concerns
- Auto-generated from code scan. Run /kata-map-codebase for detailed analysis.
```

6. Write to `.planning/intel/summary.md`
7. Print: `update-intel-summary.cjs: regenerated summary.md ({N} files indexed)`
8. Use `#!/usr/bin/env node` shebang and `'use strict';`
9. Handle missing files gracefully (exit 0, not error)

CRITICAL: Check for `.planning/codebase/` existence BEFORE overwriting summary.md. Brownfield projects that ran `/kata-map-codebase` have a richer summary from generate-intel.js. This script must not downgrade it.
  </action>
  <verify>
Create a temp `.planning/intel/` with populated index.json (a few files) and conventions.json. Run the script. Verify:
- summary.md is regenerated with file count stats
- summary.md contains extension breakdown
- summary.md contains layer breakdown
- Exit cleanly when totalFiles == 0
- Exit cleanly when .planning/codebase/ exists
  </verify>
  <done>update-intel-summary.cjs regenerates summary.md from code-scan data for greenfield projects</done>
</task>

<task type="auto">
  <name>Task 2: Modify kata-execute-phase step 7.25 with smart gate logic</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
Replace the existing step 7.25 block in `skills/kata-execute-phase/SKILL.md` with smart gate logic that handles three cases:

**Replace the entire step 7.25 section** (from `7.25. **Update codebase index` through the `|| true` closing) with:

```markdown
7.25. **Update codebase index (smart scan)**

If `.planning/intel/index.json` exists, determine scan mode and run the appropriate scan. After scanning, update summary.md if needed.

```bash
if [ -f ".planning/intel/index.json" ]; then
  # Determine scan mode: full (greenfield first population) vs incremental
  TOTAL_FILES=$(node -e "const j=JSON.parse(require('fs').readFileSync('.planning/intel/index.json','utf8')); console.log(j.stats?.totalFiles ?? j.stats?.total_files ?? 0)")

  # Locate scan script
  SCAN_SCRIPT=""
  [ -f "scripts/scan-codebase.cjs" ] && SCAN_SCRIPT="scripts/scan-codebase.cjs"
  [ -z "$SCAN_SCRIPT" ] && SCAN_SCRIPT=$(find skills/kata-map-codebase/scripts -name "scan-codebase.cjs" -type f 2>/dev/null | head -1)

  if [ -n "$SCAN_SCRIPT" ]; then
    if [ "$TOTAL_FILES" -eq 0 ]; then
      # Greenfield first population: full scan
      node "$SCAN_SCRIPT" 2>/dev/null || true
    else
      # Existing codebase: incremental scan
      PHASE_START_COMMIT=$(git log --oneline --all --grep="activate phase" --grep="${PHASE_NUM}" --all-match --format="%H" | tail -1)
      if [ -n "$PHASE_START_COMMIT" ]; then
        node "$SCAN_SCRIPT" --incremental --since "$PHASE_START_COMMIT" 2>/dev/null || true
      fi
    fi

    # Update summary.md from scan data (greenfield path only)
    SUMMARY_SCRIPT=""
    [ -f "scripts/update-intel-summary.cjs" ] && SUMMARY_SCRIPT="scripts/update-intel-summary.cjs"
    [ -z "$SUMMARY_SCRIPT" ] && SUMMARY_SCRIPT=$(find skills/kata-execute-phase/scripts -name "update-intel-summary.cjs" -type f 2>/dev/null | head -1)
    if [ -n "$SUMMARY_SCRIPT" ]; then
      node "$SUMMARY_SCRIPT" 2>/dev/null || true
    fi
  fi
fi
```

Non-blocking: all scan and summary operations use `|| true`. Failures never block phase completion.
```

Key changes from the existing step 7.25:
1. Added `TOTAL_FILES` check via `node -e` one-liner that handles both v1 (`total_files`) and v2 (`totalFiles`) field names
2. When `TOTAL_FILES == 0`: run full scan (no `--incremental` flag)
3. When `TOTAL_FILES > 0`: run incremental scan (existing behavior)
4. After any scan: run `update-intel-summary.cjs` (the script self-guards against overwriting brownfield summaries)
5. Script location uses same discovery pattern as existing code (check `scripts/` first, then `skills/` fallback)

DO NOT modify any other steps in kata-execute-phase SKILL.md. Only step 7.25 changes.
  </action>
  <verify>
Read `skills/kata-execute-phase/SKILL.md` and confirm:
1. Step 7.25 contains the `TOTAL_FILES` check
2. Full scan branch runs `node "$SCAN_SCRIPT"` without `--incremental`
3. Incremental scan branch preserves existing `--incremental --since` logic
4. `update-intel-summary.cjs` is called after scan
5. All operations are wrapped in `|| true`
6. No other steps were modified
  </verify>
  <done>kata-execute-phase step 7.25 uses smart gate: full scan for greenfield (totalFiles==0), incremental for established codebases, with summary update after each scan</done>
</task>

</tasks>

<verification>
1. `update-intel-summary.cjs` is syntactically valid: `node -c skills/kata-execute-phase/scripts/update-intel-summary.cjs`
2. Step 7.25 handles all three gate cases: no index.json (skip), totalFiles==0 (full), totalFiles>0 (incremental)
3. The `node -e` one-liner handles both v1 and v2 stats field names
4. update-intel-summary.cjs guards against overwriting brownfield summaries (checks .planning/codebase/)
5. All operations are non-blocking (|| true)
6. Script discovery pattern matches existing kata-execute-phase conventions
</verification>

<success_criteria>
- [ ] update-intel-summary.cjs creates summary.md from index.json + conventions.json data
- [ ] update-intel-summary.cjs skips when totalFiles == 0 or .planning/codebase/ exists
- [ ] Step 7.25 detects greenfield (totalFiles==0) and runs full scan
- [ ] Step 7.25 preserves incremental scan for established codebases
- [ ] Step 7.25 calls update-intel-summary.cjs after scan completes
- [ ] All operations are non-blocking
- [ ] No other steps in kata-execute-phase were modified
</success_criteria>

<output>
After completion, create `.planning/phases/pending/56-greenfield-integration/56-02-SUMMARY.md`
</output>
