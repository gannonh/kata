---
phase: 41-validation-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-doctor/scripts/check-config.sh
  - skills/kata-doctor/scripts/check-template-drift.sh
autonomous: true
source_issue: ""

must_haves:
  truths:
    - "check-config.sh exits 0 silently when .planning/config.json does not exist"
    - "check-config.sh prints [kata] Config warning for unknown keys and [kata] Config error for type mismatches"
    - "check-config.sh always exits 0, even when validation errors are found"
    - "check-config.sh uses inline Node.js heredoc with single-quoted delimiter (NODE_EOF) to prevent Bash variable expansion"
    - "check-template-drift.sh exits 0 silently when .planning/templates/ does not exist or contains no .md files"
    - "check-template-drift.sh uses sibling discovery (two levels up from scripts/ to skills/) to find default templates"
    - "check-template-drift.sh does not reference CLAUDE_PLUGIN_ROOT"
    - "check-template-drift.sh prints [kata] Template drift: {filename} missing required field(s): {fields} for drifted overrides"
    - "check-template-drift.sh always exits 0"
    - "Neither script references CLAUDE_PLUGIN_ROOT"
  artifacts:
    - skills/kata-doctor/scripts/check-config.sh
    - skills/kata-doctor/scripts/check-template-drift.sh
  key_links:
    - "check-config.sh schema matches the KNOWN_KEYS object in hooks/kata-config-validator.js"
    - "check-template-drift.sh schema parsing matches parseSchemaComment() in hooks/kata-template-drift.js"
    - "Both scripts follow the inline Node.js heredoc pattern from skills/kata-configure-settings/scripts/read-pref.sh"
    - "check-template-drift.sh uses the same sibling discovery pattern as skills/kata-execute-phase/scripts/resolve-template.sh"
---

<objective>
Create two Bash validation scripts in `kata-doctor/scripts/` that port the validation logic from the existing SessionStart hooks (`kata-config-validator.js` and `kata-template-drift.js`).

Purpose: These scripts provide the same validation as the hooks but run from any installation layout (plugin, skills-only, manual). They use the sibling discovery pattern from Phase 40 and the inline Node.js heredoc pattern from `read-pref.sh`.
Output: Two executable scripts in `skills/kata-doctor/scripts/`.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/41-validation-migration/41-RESEARCH.md

@hooks/kata-config-validator.js
@hooks/kata-template-drift.js
@skills/kata-configure-settings/scripts/read-pref.sh
@skills/kata-execute-phase/scripts/resolve-template.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check-config.sh validation script</name>
  <files>skills/kata-doctor/scripts/check-config.sh</files>
  <action>
Create `skills/kata-doctor/scripts/check-config.sh` that ports the logic from `hooks/kata-config-validator.js` to a Bash script with inline Node.js.

**Script contract:**
- Input: None (reads `.planning/config.json` from cwd)
- Output: Warning/error messages to stdout (one per issue), prefixed with `[kata]`
- Exit: Always 0 (warnings only, never blocks)

**Implementation:**
1. Shebang: `#!/usr/bin/env bash` with `set -euo pipefail`
2. Early exit: `[ -f .planning/config.json ] || exit 0`
3. Inline Node.js block using `node << 'NODE_EOF'` (single-quoted to prevent expansion)
4. Port the KNOWN_KEYS schema exactly from `hooks/kata-config-validator.js` (17 keys covering mode, depth, model_profile, commit_docs, pr_workflow, parallelization, workflow.*, github.*, workflows.*)
5. Port `flattenConfig()` and `validateValue()` functions exactly
6. Read `.planning/config.json`, flatten, validate each entry
7. Print `[kata] Config warning: Unknown key 'X'` for unknown keys
8. Print `[kata] Config error: Invalid value for 'X': expected {type}, got '{value}'` for type mismatches
9. Wrap everything in try/catch that silently exits
10. End with `exit 0` after the heredoc

**Reference:** Follow the same heredoc pattern as `skills/kata-configure-settings/scripts/read-pref.sh` (single-quoted delimiter, data via process.env or inline, require('fs')).

Make the script executable: `chmod +x skills/kata-doctor/scripts/check-config.sh`
  </action>
  <verify>
```bash
# Script exists and is executable
[ -x skills/kata-doctor/scripts/check-config.sh ] && echo "OK: executable" || echo "FAIL: not executable"

# No CLAUDE_PLUGIN_ROOT references
grep -c "CLAUDE_PLUGIN_ROOT" skills/kata-doctor/scripts/check-config.sh && echo "FAIL" || echo "OK: no CLAUDE_PLUGIN_ROOT"

# Uses single-quoted heredoc delimiter
grep -c "'NODE_EOF'" skills/kata-doctor/scripts/check-config.sh | grep -q "[1-9]" && echo "OK: quoted heredoc" || echo "FAIL: unquoted heredoc"

# Test with no config file (should exit 0 silently)
cd /tmp && rm -rf .planning && bash /Users/gannonhall/dev/kata/kata-orchestrator/skills/kata-doctor/scripts/check-config.sh; echo "exit: $?"

# Test with valid config
mkdir -p /tmp/.planning && echo '{"mode":"yolo","depth":"standard"}' > /tmp/.planning/config.json
cd /tmp && bash /Users/gannonhall/dev/kata/kata-orchestrator/skills/kata-doctor/scripts/check-config.sh; echo "exit: $?"

# Test with invalid config (should print warnings but exit 0)
echo '{"mode":"invalid","unknown_key":true}' > /tmp/.planning/config.json
cd /tmp && bash /Users/gannonhall/dev/kata/kata-orchestrator/skills/kata-doctor/scripts/check-config.sh; echo "exit: $?"
rm -rf /tmp/.planning
```
  </verify>
  <done>check-config.sh exists, is executable, validates config.json with correct schema, prints [kata] prefixed warnings/errors, always exits 0, uses single-quoted heredoc, and has zero references to CLAUDE_PLUGIN_ROOT.</done>
</task>

<task type="auto">
  <name>Task 2: Create check-template-drift.sh validation script</name>
  <files>skills/kata-doctor/scripts/check-template-drift.sh</files>
  <action>
Create `skills/kata-doctor/scripts/check-template-drift.sh` that ports the logic from `hooks/kata-template-drift.js` to a Bash script with inline Node.js.

**Script contract:**
- Input: None (reads `.planning/templates/` from cwd, discovers sibling skills from script location)
- Output: Warning messages to stdout (one per drifted template), prefixed with `[kata]`
- Exit: Always 0

**Implementation:**
1. Shebang: `#!/usr/bin/env bash` with `set -euo pipefail`
2. Early exit if `.planning/templates` directory doesn't exist: `[ -d ".planning/templates" ] || exit 0`
3. Early exit if no `.md` files in the directory: `ls ".planning/templates"/*.md >/dev/null 2>&1 || exit 0`
4. Discover sibling skills directory using the Phase 40 pattern:
   ```
   SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd -P)"
   SKILLS_DIR="$(cd "${SCRIPT_DIR}/../.." && pwd -P)"
   ```
   This navigates: `kata-doctor/scripts/` -> `kata-doctor/` -> `skills/`
5. Pass `TEMPLATES_DIR` and `SKILLS_DIR` as environment variables to the inline Node.js block
6. Inline Node.js block using `TEMPLATES_DIR=".planning/templates" SKILLS_DIR="$SKILLS_DIR" node << 'NODE_EOF'`
7. Port `parseSchemaComment()`, `parseFrontmatter()`, and `checkFieldPresence()` exactly from `hooks/kata-template-drift.js`
8. For each `.md` file in TEMPLATES_DIR:
   a. Glob `SKILLS_DIR/kata-*/references/{filename}` to find the default
   b. Parse `kata-template-schema` comment from the default
   c. Check the override for missing required fields
   d. Print `[kata] Template drift: {filename} missing required field(s): {fields}. Run resolve-template.sh for defaults.`
9. Wrap in try/catch, end with `exit 0`

**Do NOT:**
- Reference CLAUDE_PLUGIN_ROOT anywhere
- Use `$(dirname "$0")` for more than establishing SCRIPT_DIR
- Fail with non-zero exit code for any reason

Make the script executable: `chmod +x skills/kata-doctor/scripts/check-template-drift.sh`
  </action>
  <verify>
```bash
# Script exists and is executable
[ -x skills/kata-doctor/scripts/check-template-drift.sh ] && echo "OK: executable" || echo "FAIL: not executable"

# No CLAUDE_PLUGIN_ROOT references
grep -c "CLAUDE_PLUGIN_ROOT" skills/kata-doctor/scripts/check-template-drift.sh && echo "FAIL" || echo "OK: no CLAUDE_PLUGIN_ROOT"

# Uses sibling discovery (two levels up)
grep -c 'SCRIPT_DIR/../..' skills/kata-doctor/scripts/check-template-drift.sh | grep -q "[1-9]" && echo "OK: sibling discovery" || echo "FAIL: no sibling discovery"

# Test with no overrides directory (should exit 0 silently)
cd /Users/gannonhall/dev/kata/kata-orchestrator
rm -rf /tmp/test-drift && mkdir -p /tmp/test-drift && cd /tmp/test-drift
bash /Users/gannonhall/dev/kata/kata-orchestrator/skills/kata-doctor/scripts/check-template-drift.sh; echo "exit: $?"

# Test with valid override (copy a real template)
cd /Users/gannonhall/dev/kata/kata-orchestrator
mkdir -p .planning/templates
cp skills/kata-execute-phase/references/summary-template.md .planning/templates/
bash skills/kata-doctor/scripts/check-template-drift.sh; echo "exit: $?"

# Test with drifted override (minimal file missing required fields)
echo "# Minimal override" > .planning/templates/summary-template.md
bash skills/kata-doctor/scripts/check-template-drift.sh
rm -rf .planning/templates
```
  </verify>
  <done>check-template-drift.sh exists, is executable, uses sibling discovery to find default templates, detects missing required fields in overrides, prints [kata] prefixed drift warnings, always exits 0, and has zero references to CLAUDE_PLUGIN_ROOT.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify both validation scripts work correctly</name>
  <what-built>Two Bash validation scripts in `skills/kata-doctor/scripts/` that port the SessionStart hook logic. `check-config.sh` validates `.planning/config.json` against the known schema. `check-template-drift.sh` checks project template overrides for missing required fields using sibling discovery.</what-built>
  <how-to-verify>
1. Test config validation with no config:
   ```bash
   cd /tmp && rm -rf .planning
   bash /path/to/skills/kata-doctor/scripts/check-config.sh; echo "exit: $?"
   # Expected: no output, exit 0
   ```
2. Test config validation with bad values:
   ```bash
   mkdir -p /tmp/.planning && echo '{"mode":"invalid","unknown_key":true}' > /tmp/.planning/config.json
   cd /tmp && bash /path/to/skills/kata-doctor/scripts/check-config.sh
   # Expected: two warnings, exit 0
   rm -rf /tmp/.planning
   ```
3. Test template drift with no overrides:
   ```bash
   cd /path/to/kata-orchestrator
   bash skills/kata-doctor/scripts/check-template-drift.sh; echo "exit: $?"
   # Expected: no output, exit 0 (unless .planning/templates/ exists in the project)
   ```
4. Verify no CLAUDE_PLUGIN_ROOT in either script:
   ```bash
   grep -r "CLAUDE_PLUGIN_ROOT" skills/kata-doctor/scripts/check-*.sh && echo "FAIL" || echo "OK"
   ```
  </how-to-verify>
  <resume-signal>Say "verified" to continue or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
- check-config.sh validates all 17 known config keys with correct types
- check-template-drift.sh discovers defaults via sibling skill directories
- Both scripts exit 0 always (warnings printed to stdout, never blocking)
- Both scripts use inline Node.js with single-quoted heredoc delimiters
- Neither script references CLAUDE_PLUGIN_ROOT
- Both scripts handle missing input gracefully (no config file, no templates dir)
</verification>

<success_criteria>
- VAL-01 (partial): Template drift detection script created and functional
- VAL-02 (partial): Config validation script created and functional
- VAL-03 (partial): Both scripts use sibling discovery, no CLAUDE_PLUGIN_ROOT dependency
</success_criteria>

<output>
After completion, create `.planning/phases/active/41-validation-migration/41-01-SUMMARY.md`
</output>
