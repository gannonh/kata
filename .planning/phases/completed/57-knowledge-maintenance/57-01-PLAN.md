---
phase: 57-knowledge-maintenance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-map-codebase/scripts/detect-stale-intel.cjs
  - skills/kata-execute-phase/scripts/check-conventions.cjs
autonomous: true
must_haves:
  truths:
    - detect-stale-intel.cjs reads index.json, groups files by lastIndexed commit, runs batch git diff, and outputs stale file list as JSON
    - detect-stale-intel.cjs falls back to top-level commitHash when entries lack per-file lastIndexed
    - detect-stale-intel.cjs uses batch git diff (O(1) per unique commit), not per-file git log
    - check-conventions.cjs reads conventions.json and checks export names in specified files against the dominant naming pattern
    - check-conventions.cjs skips when confidence < 0.7 or pattern is insufficient_data or mixed
    - check-conventions.cjs filters input files to SUPPORTED_EXTENSIONS (no false positives on .md/.json/.sh)
    - Both scripts exit 0 gracefully when input data is missing or empty
    - Both scripts are self-contained (no cross-skill imports)
  artifacts:
    - skills/kata-map-codebase/scripts/detect-stale-intel.cjs
    - skills/kata-execute-phase/scripts/check-conventions.cjs
  key_links:
    - detect-stale-intel.cjs output is consumed by plan 02 orchestrator integration
    - check-conventions.cjs reuses classifyIdentifier() and extractExports() logic from scan-codebase.cjs (copied, not imported, due to build system cross-skill ref prohibition)
    - detect-stale-intel.cjs reads the same index.json written by scan-codebase.cjs
---

<objective>
Create two Node.js CJS scripts: `detect-stale-intel.cjs` for staleness detection (MAINT-01) and `check-conventions.cjs` for convention enforcement (MAINT-03).

These scripts are standalone tools that plan 02 will wire into the kata-execute-phase orchestrator. Building them first lets us test in isolation before integration.

Output: Two new CJS scripts in their respective skill `scripts/` directories
</objective>

<execution_context>
<!-- Executor agent has built-in instructions -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/57-knowledge-maintenance/57-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create detect-stale-intel.cjs</name>
  <files>skills/kata-map-codebase/scripts/detect-stale-intel.cjs</files>
  <action>
Create a Node.js CJS script at `skills/kata-map-codebase/scripts/detect-stale-intel.cjs` that detects stale entries in `.planning/intel/index.json` by comparing `lastIndexed` commit hashes against current git state.

The script must:

1. Use `#!/usr/bin/env node` shebang and `'use strict';`
2. Use the same `resolveProjectRoot()` pattern from scan-codebase.cjs:
   - Check `KATA_PROJECT_ROOT` env var
   - Check CWD for `.planning/`
   - Check CWD/main for `.planning/`
   - Throw explicit error if none found
3. Read `.planning/intel/index.json`. Exit 0 with empty JSON if file missing.
4. Extract per-file `lastIndexed` commit hashes. Fall back to top-level `commitHash` when an entry lacks `lastIndexed`. Skip wildcard entries (paths containing `*`).
5. Group files by their lastIndexed commit to minimize git commands.
6. For each unique commit, run ONE `git diff --name-only {commit}..HEAD` command. Intersect results with indexed paths.
7. Handle git errors gracefully: if a commit hash is invalid (deleted/rebased), treat all files in that group as stale.
8. Output JSON to stdout:
   ```json
   {
     "staleFiles": ["path/to/file1.js", "path/to/file2.ts"],
     "freshFiles": ["path/to/file3.js"],
     "totalIndexed": 47,
     "staleCount": 2,
     "stalePct": 0.04,
     "oldestStaleCommit": "abc123f",
     "hasDocBasedEntries": false
   }
   ```
   `hasDocBasedEntries` is true when `.planning/codebase/` exists and entries lack `lastIndexed` (brownfield doc-based intel).
9. Exit code: 0 always (non-blocking). The JSON output indicates staleness state.
10. Export `detectStaleFiles` function via `module.exports` for testing.
11. Run as CLI when `require.main === module`.

CRITICAL: Use batch `git diff --name-only` (one command per unique lastIndexed commit), not per-file `git log`. The research benchmarked this at <50ms vs 265ms for 47 files.

CRITICAL: Do NOT import from scan-codebase.cjs. The build system forbids cross-skill references. This script must be self-contained.

Test the script output by reading the existing `.planning/intel/index.json` in this repo and verifying the JSON output parses correctly.
  </action>
  <verify>
Run the script from the project root:
```bash
node skills/kata-map-codebase/scripts/detect-stale-intel.cjs
```
Verify:
- Output is valid JSON
- `totalIndexed` matches the number of non-wildcard entries in index.json
- `staleFiles` and `freshFiles` arrays contain file paths (strings)
- `stalePct` is between 0 and 1
- Script exits 0
- `node -c skills/kata-map-codebase/scripts/detect-stale-intel.cjs` passes syntax check
  </verify>
  <done>detect-stale-intel.cjs outputs valid JSON with stale/fresh file lists using batch git diff per unique commit group</done>
</task>

<task type="auto">
  <name>Task 2: Create check-conventions.cjs</name>
  <files>skills/kata-execute-phase/scripts/check-conventions.cjs</files>
  <action>
Create a Node.js CJS script at `skills/kata-execute-phase/scripts/check-conventions.cjs` that checks export naming conventions in specified files against patterns in `conventions.json`.

The script must:

1. Use `#!/usr/bin/env node` shebang and `'use strict';`
2. Use the same `resolveProjectRoot()` pattern from scan-codebase.cjs.
3. Accept CLI args: `--files file1.js file2.ts ...` and optional `--conventions path/to/conventions.json` (defaults to `.planning/intel/conventions.json`).
4. Filter input files to supported code extensions only:
   `js, mjs, cjs, ts, mts, cts, jsx, tsx, py, go, rs, java`
   Skip all other file types silently. This prevents false positives on .md, .json, .sh files.
5. Read conventions.json. Extract `naming.exports.pattern` and `naming.exports.confidence`.
6. Skip checks entirely (output empty violations, `skipped` reason) if:
   - conventions.json missing or unreadable
   - `pattern` is `insufficient_data` or `mixed`
   - `confidence` < 0.7
   - No files remain after extension filtering
7. For each supported file:
   a. Read file content from `{projectRoot}/{filePath}`
   b. Extract exported identifiers using the same regex patterns as scan-codebase.cjs. Copy the extraction functions inline (do NOT import from scan-codebase.cjs due to build system cross-skill prohibition). The functions needed:
      - `classifyIdentifier(name)` — classify as camelCase, PascalCase, snake_case, SCREAMING_SNAKE, or other
      - `extractJSExports(source)` — for .js/.ts/.jsx/.tsx/.mjs/.cjs/.mts/.cts
      - `extractPythonExports(source)` — for .py
      - `extractGoExports(source)` — for .go
      - `extractRustExports(source)` — for .rs
      - `extractJavaExports(source)` — for .java
      - `getLanguage(filePath)` — extension to language mapping
      - `stripComments(source)` and `stripPythonComments(source)` — needed by extractors
   c. Classify each export name and compare to expected pattern
   d. Record violations where classification differs from expected pattern (ignore `other` classification)

8. Output JSON to stdout:
   ```json
   {
     "violations": [
       {
         "file": "src/utils/my_helper.ts",
         "type": "naming",
         "export": "get_user_data",
         "found": "snake_case",
         "expected": "camelCase",
         "severity": "warning"
       }
     ],
     "checked": 2,
     "passed": 1,
     "conventionPattern": "camelCase",
     "confidence": 0.85
   }
   ```
   Or when skipped:
   ```json
   {
     "violations": [],
     "checked": 0,
     "skipped": "insufficient convention data"
   }
   ```

9. Exit code: 0 always (non-blocking). Convention violations are warnings, never blockers.
10. Export `checkConventions` function via `module.exports` for testing.
11. Run as CLI when `require.main === module`.

CRITICAL: Copy the regex patterns from scan-codebase.cjs exactly. Do not rewrite or simplify them. The patterns have been tested against JS/TS/Python/Go/Rust/Java codebases.

CRITICAL: `classifyIdentifier()` must match scan-codebase.cjs exactly:
```javascript
function classifyIdentifier(name) {
  if (/^[A-Z][A-Z0-9_]+$/.test(name) && name.includes('_')) return 'SCREAMING_SNAKE';
  if (/^[A-Z][a-zA-Z0-9]*$/.test(name)) return 'PascalCase';
  if (/^[a-z][a-zA-Z0-9]*$/.test(name)) return 'camelCase';
  if (/^[a-z][a-z0-9]*(?:_[a-z0-9]+)+$/.test(name)) return 'snake_case';
  return 'other';
}
```

Test the script by running it against a source file in this repo with the existing conventions.json.
  </action>
  <verify>
Run the script from the project root:
```bash
node skills/kata-execute-phase/scripts/check-conventions.cjs --files bin/install.js skills/kata-map-codebase/scripts/scan-codebase.cjs
```
Verify:
- Output is valid JSON
- `checked` equals the number of supported files passed
- `conventionPattern` matches conventions.json `naming.exports.pattern`
- Violations (if any) have file, type, export, found, expected, severity fields
- Script exits 0
- `node -c skills/kata-execute-phase/scripts/check-conventions.cjs` passes syntax check

Also test skip path:
```bash
node skills/kata-execute-phase/scripts/check-conventions.cjs --files README.md
```
Verify output has `checked: 0` (README.md filtered out as unsupported extension).
  </verify>
  <done>check-conventions.cjs checks export naming against conventions.json patterns, outputs violations as JSON, filters to supported code files only</done>
</task>

</tasks>

<verification>
1. `detect-stale-intel.cjs` syntax check passes: `node -c skills/kata-map-codebase/scripts/detect-stale-intel.cjs`
2. `check-conventions.cjs` syntax check passes: `node -c skills/kata-execute-phase/scripts/check-conventions.cjs`
3. `detect-stale-intel.cjs` outputs valid JSON when run from project root
4. `check-conventions.cjs` outputs valid JSON when run with --files against any .js file
5. Both scripts exit 0 when `.planning/intel/` is missing (graceful degradation)
6. Neither script contains `require('../kata-` or `require('./scan-codebase` (no cross-skill imports)
7. `classifyIdentifier()` regex in check-conventions.cjs matches scan-codebase.cjs exactly
</verification>

<success_criteria>
- [ ] detect-stale-intel.cjs exists at skills/kata-map-codebase/scripts/
- [ ] detect-stale-intel.cjs reads index.json and outputs JSON with staleFiles/freshFiles/stalePct
- [ ] detect-stale-intel.cjs groups files by lastIndexed commit and uses batch git diff
- [ ] detect-stale-intel.cjs falls back to top-level commitHash for entries without lastIndexed
- [ ] check-conventions.cjs exists at skills/kata-execute-phase/scripts/
- [ ] check-conventions.cjs reads conventions.json and checks export naming in specified files
- [ ] check-conventions.cjs filters to supported code extensions (no false positives on .md/.json/.sh)
- [ ] check-conventions.cjs skips when confidence < 0.7 or pattern is insufficient_data/mixed
- [ ] Both scripts exit 0 and produce valid JSON
- [ ] Both scripts are self-contained (no cross-skill imports)
</success_criteria>

<output>
After completion, create `.planning/phases/pending/57-knowledge-maintenance/57-01-SUMMARY.md`
</output>
