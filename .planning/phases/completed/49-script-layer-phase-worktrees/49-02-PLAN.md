---
phase: 49-script-layer-phase-worktrees
plan: 02
type: execute
wave: 2
depends_on: [49-01]
files_modified:
  - skills/kata-execute-phase/scripts/manage-worktree.sh
  - tests/scripts/manage-worktree.test.js
autonomous: true
must_haves:
  truths:
    - resolve_base_branch function removed from manage-worktree.sh
    - cmd_create requires explicit base branch (no fallback to main/ current branch)
    - cmd_merge merges into the phase worktree directory passed as argument, not into main/
    - cleanup-phase subcommand removes phase worktree and deletes phase branch
    - Existing create/merge/list subcommands still work with explicit base branch
  artifacts:
    - skills/kata-execute-phase/scripts/manage-worktree.sh
    - tests/scripts/manage-worktree.test.js
  key_links:
    - cmd_merge target directory -> phase worktree path (not main/)
    - cmd_create base branch -> phase branch passed by caller
    - cleanup-phase -> removes worktree via GIT_DIR=.bare git worktree remove
---

<objective>
Modify `manage-worktree.sh` to: (1) remove `resolve_base_branch` so base branch is always explicit, (2) change `cmd_merge` to merge into the phase worktree directory instead of `main/`, (3) add `cleanup-phase` subcommand. Update tests.

Purpose: Plan branches must merge into the phase worktree, not `main/`. The caller (orchestrator) always knows the phase branch and worktree path.
Output: Modified `manage-worktree.sh`, updated tests.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/refactor-worktree-phases.md
@skills/kata-execute-phase/scripts/manage-worktree.sh
@tests/scripts/manage-worktree.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify manage-worktree.sh for explicit base branch, phase worktree merge target, and cleanup-phase</name>
  <files>skills/kata-execute-phase/scripts/manage-worktree.sh</files>
  <action>
Three changes to `manage-worktree.sh`:

**A. Remove `resolve_base_branch` (MT-02)**

Delete the `resolve_base_branch` function (lines 44-53). It falls back to reading `main/`'s current branch, which is the exact behavior we're eliminating.

In `cmd_create`: make `base_branch` a required third argument. Change from:
```bash
base_branch=$(resolve_base_branch "${3:-}")
```
To:
```bash
local base_branch="${3:?Usage: manage-worktree.sh create <phase> <plan> <base-branch>}"
```

In `cmd_merge`: make `base_branch` a required third argument, and add a required fourth argument `merge_target_dir` (the phase worktree directory). Change from:
```bash
base_branch=$(resolve_base_branch "${3:-}")
```
To:
```bash
local base_branch="${3:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"
local merge_target_dir="${4:?Usage: manage-worktree.sh merge <phase> <plan> <base-branch> <merge-dir>}"
```

**B. Change cmd_merge to merge into phase worktree directory (MT-01)**

Replace every reference to `main` as the merge target with `$merge_target_dir`:

1. Remove the `main` directory existence check:
```bash
# DELETE:
if [ ! -d "main" ]; then
  echo "Error: main worktree directory not found" >&2
  exit 1
fi
```

Replace with:
```bash
if [ ! -d "$merge_target_dir" ]; then
  echo "Error: Merge target directory $merge_target_dir not found" >&2
  exit 1
fi
```

2. Replace `git -C main checkout "$base_branch"` with `git -C "$merge_target_dir" checkout "$base_branch"`.

3. Replace the untracked file cleanup loop: change `main/$file` references to `$merge_target_dir/$file`, and change `git -C main ls-files` to `git -C "$merge_target_dir" ls-files`.

4. Replace `git -C main merge` with `git -C "$merge_target_dir" merge`.

5. Update the merge conflict error message to reference `$merge_target_dir` instead of `main/`.

**C. Add cleanup-phase subcommand (WT-05)**

Add a new function `cmd_cleanup_phase`:

```bash
cmd_cleanup_phase() {
  local phase_worktree="${1:?Usage: manage-worktree.sh cleanup-phase <worktree-path> <branch>}"
  local phase_branch="${2:?Usage: manage-worktree.sh cleanup-phase <worktree-path> <branch>}"

  if [ ! -d "$phase_worktree" ]; then
    echo "Error: Phase worktree directory $phase_worktree not found" >&2
    exit 1
  fi

  # Check for uncommitted changes
  if [ -n "$(git -C "$phase_worktree" status --porcelain)" ]; then
    echo "Error: Phase worktree has uncommitted changes. Commit or stash first." >&2
    exit 1
  fi

  GIT_DIR=.bare git worktree remove "$phase_worktree" >&2
  GIT_DIR=.bare git branch -d "$phase_branch" >&2

  echo "CLEANED=true"
  echo "STATUS=cleaned"
}
```

Add to the case statement:
```bash
cleanup-phase) cmd_cleanup_phase "$@" ;;
```

**D. Update header comment and usage text**

Update the script header to reflect the new signatures:
```
#   create <phase> <plan> <base-branch>            — Create worktree for a plan
#   merge  <phase> <plan> <base-branch> <merge-dir> — Merge plan branch and remove worktree
#   cleanup-phase <worktree-path> <branch>          — Remove phase worktree and branch
#   list                                            — List active plan worktrees
```

Update the usage output in the no-subcommand case to match.
  </action>
  <verify>
Read the modified file. Confirm:
- `resolve_base_branch` function does not exist
- `cmd_create` requires 3 positional args (phase, plan, base-branch)
- `cmd_merge` requires 4 positional args (phase, plan, base-branch, merge-dir)
- No reference to `main` as a hardcoded merge target directory
- `cleanup-phase` subcommand exists with worktree remove and branch delete
- `cmd_merge` error messages reference `$merge_target_dir` not `main/`
  </verify>
  <done>
`manage-worktree.sh` no longer has `resolve_base_branch`. `cmd_create` and `cmd_merge` require explicit base branch. `cmd_merge` merges into the caller-specified directory. `cleanup-phase` subcommand removes phase worktree and branch.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update manage-worktree.sh tests for new signatures and cleanup-phase</name>
  <files>tests/scripts/manage-worktree.test.js</files>
  <action>
Update tests to match the new function signatures and add tests for `cleanup-phase`.

**A. Update create tests**

The create subcommand now requires an explicit base branch. Change:
```js
runManageWorktree(tmpDir, 'create 48 01')
```
To:
```js
runManageWorktree(tmpDir, 'create 48 01 main')
```

Apply this to every test that calls `create`.

**B. Update merge tests**

The merge subcommand now requires base branch AND merge target directory. The merge target is the phase worktree, not `main/`.

For testing, create a phase worktree before running merge tests:

```js
// Create a phase worktree (simulates what create-phase-branch.sh does)
execSync('GIT_DIR=.bare git worktree add phase-wt -b feat/test main', {
  cwd: tmpDir, env: GIT_ENV, stdio: 'pipe'
});
```

Then change merge calls from:
```js
runManageWorktree(tmpDir, 'merge 48 01')
```
To:
```js
runManageWorktree(tmpDir, 'merge 48 01 feat/test phase-wt')
```

Update the merge assertion that checks for the file in `main/`:
```js
// Change from: fs.existsSync(path.join(tmpDir, 'main', 'hello.txt'))
// Change to:   fs.existsSync(path.join(tmpDir, 'phase-wt', 'hello.txt'))
```

The plan worktree still forks from the base branch (feat/test), and merges back into the phase worktree directory (phase-wt).

For the create call in merge tests, pass `feat/test` as base branch:
```js
runManageWorktree(tmpDir, 'create 48 01 feat/test')
```

**C. Add cleanup-phase tests**

Add a new `describe('cleanup-phase subcommand')` block:

Test 1: "removes phase worktree and branch"
- Create a phase worktree: `GIT_DIR=.bare git worktree add phase-wt -b feat/test main`
- Run: `runManageWorktree(tmpDir, 'cleanup-phase phase-wt feat/test')`
- Assert: `kv.STATUS === 'cleaned'` and `kv.CLEANED === 'true'`
- Assert: `phase-wt` directory no longer exists
- Assert: branch `feat/test` no longer exists (`git show-ref --verify refs/heads/feat/test` fails)

Test 2: "exits 1 when phase worktree directory does not exist"
- Run: `runManageWorktree(tmpDir, 'cleanup-phase nonexistent feat/test', true)`
- Assert: exit code 1, stderr mentions "not found"

Test 3: "exits 1 when phase worktree has uncommitted changes"
- Create phase worktree
- Write an uncommitted file in it
- Run cleanup-phase, expect failure
- Assert stderr mentions "uncommitted changes"

**D. Update precondition tests if needed**

The usage text changed. Update the "shows usage when no subcommand given" test if it checks for specific usage text. The test currently checks `result.stdout.includes('Usage')` which is generic enough.

  </action>
  <verify>
```bash
npm run build:plugin && node --test tests/scripts/manage-worktree.test.js
```
All tests pass. Tests cover: create with explicit base, merge into phase worktree, cleanup-phase success, cleanup-phase error cases.
  </verify>
  <done>
All `manage-worktree.test.js` tests pass. Tests use explicit base branch for create/merge. Merge tests verify files appear in phase worktree (not main/). cleanup-phase tests verify worktree removal, branch deletion, and error cases.
  </done>
</task>

</tasks>

<verification>
```bash
npm run build:plugin && npm run test:scripts
```

All script tests pass. Specific checks:
- `node --test tests/scripts/create-phase-branch.test.js` passes
- `node --test tests/scripts/manage-worktree.test.js` passes
- `grep -c "resolve_base_branch" skills/kata-execute-phase/scripts/manage-worktree.sh` returns 0
- `grep -c "git checkout" skills/kata-execute-phase/scripts/create-phase-branch.sh` returns 0
</verification>

<success_criteria>
- `resolve_base_branch` removed from `manage-worktree.sh`
- `cmd_create` requires explicit base branch argument
- `cmd_merge` merges into caller-specified directory, not `main/`
- `cleanup-phase` subcommand removes phase worktree and branch
- `cleanup-phase` errors on missing directory and uncommitted changes
- All tests in `manage-worktree.test.js` pass
- All tests in `create-phase-branch.test.js` still pass
</success_criteria>

<output>
After completion, create `.planning/phases/49-script-layer-phase-worktrees/49-02-SUMMARY.md`
</output>
