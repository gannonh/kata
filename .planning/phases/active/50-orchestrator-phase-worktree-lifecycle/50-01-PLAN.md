---
phase: 50-orchestrator-phase-worktree-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/kata-execute-phase/SKILL.md
autonomous: true

must_haves:
  truths:
    - "Step 1.5 stores WORKTREE_PATH as PHASE_WORKTREE_PATH and BRANCH as PHASE_BRANCH from create-phase-branch.sh output"
    - "Step 4 worktree create passes PHASE_BRANCH as third arg to manage-worktree.sh create"
    - "Step 4 worktree merge passes PHASE_BRANCH and PHASE_WORKTREE_PATH as third and fourth args to manage-worktree.sh merge"
    - "Step 4 working directory injection uses PHASE_WORKTREE_PATH when PR_WORKFLOW=true AND WORKTREE_ENABLED=false"
    - "Step 4 working directory injection uses plan worktree path when PR_WORKFLOW=true AND WORKTREE_ENABLED=true"
    - "Step 10.5 pushes and creates PR from phase worktree using git -C PHASE_WORKTREE_PATH"
    - "Step 10.5 calls manage-worktree.sh cleanup-phase after PR creation or local merge"
    - "Step 10 git add/commit commands use GIT_DIR_FLAG array with PR_WORKFLOW-conditional -C flag"
    - "No git checkout commands target main/ during phase execution"
  artifacts:
    - path: "skills/kata-execute-phase/SKILL.md"
      provides: "Updated orchestrator with phase worktree lifecycle wired into execution flow"
  key_links:
    - from: "SKILL.md step 1.5"
      to: "create-phase-branch.sh"
      via: "eval output captures WORKTREE_PATH as PHASE_WORKTREE_PATH"
    - from: "SKILL.md step 4"
      to: "manage-worktree.sh create/merge"
      via: "PHASE_BRANCH and PHASE_WORKTREE_PATH passed as explicit args"
    - from: "SKILL.md step 10.5"
      to: "manage-worktree.sh cleanup-phase"
      via: "PHASE_WORKTREE_PATH and BRANCH passed after PR/merge"
---

<objective>
Update SKILL.md orchestrator to wire phase worktree lifecycle into phase execution. Step 1.5 captures phase worktree path, step 4 passes phase branch to plan worktree operations and injects correct working directory, step 10.5 pushes/PRs from phase worktree and cleans up.

Purpose: Implements OR-01 through OR-05 and INV-01 at the orchestrator instruction level. After this plan, the SKILL.md execution flow uses phase worktrees instead of switching main/ off the main branch.
Output: Updated SKILL.md with phase worktree lifecycle integrated into steps 0.7, 1.5, 4, and 10.5.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/refactor-worktree-phases.md
@skills/kata-execute-phase/SKILL.md
@skills/kata-execute-phase/scripts/create-phase-branch.sh
@skills/kata-execute-phase/scripts/manage-worktree.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire phase worktree setup and wave execution in SKILL.md</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
Modify SKILL.md steps 0.7, 1.5, and 4 for phase worktree integration:

**Step 0.7 (Check Worktree Config):**
Add PR_WORKFLOW read here alongside WORKTREE_ENABLED (move from step 1.5 so both are available early):

```bash
WORKTREE_ENABLED=$(bash "../kata-configure-settings/scripts/read-config.sh" "worktree.enabled" "false")
PR_WORKFLOW=$(bash "../kata-configure-settings/scripts/read-config.sh" "pr_workflow" "false")
```

Store both for use in later steps.

**Step 1.5 (Create phase branch):**
The current step already calls create-phase-branch.sh and evals output. Update it to:
1. Remove the separate `PR_WORKFLOW` read (moved to step 0.7).
2. After the existing eval, add: `PHASE_WORKTREE_PATH=$WORKTREE_PATH` and `PHASE_BRANCH=$BRANCH`.
3. Change the "Store BRANCH variable" comment to "Store PHASE_WORKTREE_PATH and PHASE_BRANCH for steps 4 and 10.5."
4. Keep the activation commit logic unchanged.

The existing code already handles PR_WORKFLOW=false skip. Keep that gate.

**Step 4 (Execute waves):**

Update the worktree create block. The current code passes 2 args to manage-worktree.sh create. Add PHASE_BRANCH as third arg:

```bash
if [ "$WORKTREE_ENABLED" = "true" ] && [ "$PR_WORKFLOW" = "true" ]; then
  for plan_num in $WAVE_PLAN_NUMBERS; do
    WT_OUTPUT=$(bash "./scripts/manage-worktree.sh" create "$PHASE_NUM" "$plan_num" "$PHASE_BRANCH")
    eval "$WT_OUTPUT"
    # Stores WORKTREE_PATH, WORKTREE_BRANCH, STATUS for each plan
    # Save per-plan: WORKTREE_PATH_${plan_num}=$WORKTREE_PATH
  done
fi
```

Key change: Add `&& [ "$PR_WORKFLOW" = "true" ]` guard and `"$PHASE_BRANCH"` third arg.

Update the worktree merge block. The current code passes 2 args. Add PHASE_BRANCH and PHASE_WORKTREE_PATH as third and fourth args:

```bash
if [ "$WORKTREE_ENABLED" = "true" ] && [ "$PR_WORKFLOW" = "true" ]; then
  for plan_num in $WAVE_PLAN_NUMBERS; do
    MERGE_OUTPUT=$(bash "./scripts/manage-worktree.sh" merge "$PHASE_NUM" "$plan_num" "$PHASE_BRANCH" "$PHASE_WORKTREE_PATH")
    eval "$MERGE_OUTPUT"
    if [ "$STATUS" != "merged" ]; then
      echo "Warning: Worktree merge failed for plan $plan_num" >&2
    fi
  done
fi
```

Key change: Add `&& [ "$PR_WORKFLOW" = "true" ]` guard and `"$PHASE_BRANCH" "$PHASE_WORKTREE_PATH"` args.

**Step 4 Draft PR block:**
The current code reads branch via `git branch --show-current`. Change to use `PHASE_BRANCH` and push from phase worktree:

```bash
if [ "$PR_WORKFLOW" = "true" ]; then
  # Push from phase worktree (not main/)
  git -C "$PHASE_WORKTREE_PATH" push -u origin "$PHASE_BRANCH" 2>/dev/null || \
    git -C "$PHASE_WORKTREE_PATH" push -u --force-with-lease origin "$PHASE_BRANCH" 2>/dev/null
  if ! PR_OUTPUT=$(bash "./scripts/create-draft-pr.sh" "$PHASE_DIR" "$PHASE_BRANCH"); then
    echo "Error: Failed to create draft PR" >&2
  else
    eval "$PR_OUTPUT"
  fi
fi
```

Replace the `BRANCH=$(git branch --show-current)` line with `PHASE_BRANCH` (already set in step 1.5).

**Working directory injection in `<wave_execution>` section:**
Update the conditional logic for `<working_directory>` injection. Replace the current single condition:

Current:
```
- When `WORKTREE_ENABLED=true`: append `\n<working_directory>{worktree_path_for_this_plan}</working_directory>`
- When `WORKTREE_ENABLED=false`: Omit the `<working_directory>` block entirely (existing behavior).
```

New (three cases), implemented via this bash conditional that runs per-plan before spawning the Task() subagent:

```bash
# Resolve working directory block for this plan's subagent prompt
WORKING_DIR_BLOCK=""
if [ "$PR_WORKFLOW" = "true" ]; then
  if [ "$WORKTREE_ENABLED" = "true" ]; then
    # Plan has its own worktree — use the plan-specific path
    PLAN_WT_PATH="WORKTREE_PATH_${plan_num}"
    WORKING_DIR_BLOCK="\n<working_directory>${!PLAN_WT_PATH}</working_directory>"
  else
    # No plan worktrees — all plans share the phase worktree
    WORKING_DIR_BLOCK="\n<working_directory>${PHASE_WORKTREE_PATH}</working_directory>"
  fi
  # else: PR_WORKFLOW=false — no working_directory block (existing behavior)
fi
```

Then append `$WORKING_DIR_BLOCK` to the Task() prompt template for each plan.

Update the Task() prompt template examples in `<wave_execution>` to reflect this three-way condition. Change `{if WORKTREE_ENABLED:` to `{if PR_WORKFLOW=true AND WORKTREE_ENABLED=true:` and add the phase worktree case.

Also update the "Working directory injection (worktree mode)" description text to explain the three cases.

**Do NOT modify:** step 2 (discover plans), step 3 (group by wave), step 5 (aggregate), steps 6-9 (commit/verify/update), or any of the `<offer_next>` section.
  </action>
  <verify>
Read SKILL.md and confirm:
1. Step 0.7 reads both WORKTREE_ENABLED and PR_WORKFLOW
2. Step 1.5 stores PHASE_WORKTREE_PATH and PHASE_BRANCH
3. Step 4 worktree create passes 3 args (phase, plan, PHASE_BRANCH) with PR_WORKFLOW guard
4. Step 4 worktree merge passes 4 args (phase, plan, PHASE_BRANCH, PHASE_WORKTREE_PATH) with PR_WORKFLOW guard
5. wave_execution describes three working directory cases
6. No `git branch --show-current` in step 4 draft PR block
7. `npm run build:plugin` succeeds
  </verify>
  <done>SKILL.md steps 0.7/1.5/4 updated with phase worktree lifecycle. Working directory injection handles three cases (plan worktree, phase worktree, no worktree). manage-worktree.sh calls pass phase branch and merge target explicitly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire phase worktree PR/merge and cleanup in SKILL.md step 10.5</name>
  <files>skills/kata-execute-phase/SKILL.md</files>
  <action>
Update step 10.5 to push and create PR from the phase worktree directory, and add cleanup after PR creation or local merge.

**Replace the entire step 10.5 block** with:

```
10.5. **Push and ensure PR exists (pr_workflow only)**

    After phase completion commit, push from the phase worktree and finalize the PR:

    ```bash
    if [ "$PR_WORKFLOW" = "true" ]; then
      # Commit any remaining planning changes in the phase worktree
      if [ -n "$(git -C "$PHASE_WORKTREE_PATH" status --porcelain .planning/)" ]; then
        git -C "$PHASE_WORKTREE_PATH" add .planning/
        git -C "$PHASE_WORKTREE_PATH" commit -m "docs(${PHASE_NUM}): update planning state"
      fi

      # Push from phase worktree (not main/)
      git -C "$PHASE_WORKTREE_PATH" push -u origin "$PHASE_BRANCH"

      # Check if draft PR was created earlier
      PR_NUMBER=$(gh pr list --head "$PHASE_BRANCH" --json number --jq '.[0].number' 2>/dev/null)

      if [ -z "$PR_NUMBER" ]; then
        # Draft PR creation failed earlier — create PR now
        PR_OUTPUT=$(bash "./scripts/create-draft-pr.sh" "$PHASE_DIR" "$PHASE_BRANCH" 2>&1) || true
        PR_NUMBER=$(gh pr list --head "$PHASE_BRANCH" --json number --jq '.[0].number' 2>/dev/null)
      fi

      # Mark PR ready for review (if it exists)
      if [ -n "$PR_NUMBER" ]; then
        gh pr ready "$PR_NUMBER" 2>/dev/null || true
        PR_URL=$(gh pr view "$PR_NUMBER" --json url --jq '.url' 2>/dev/null)
        echo "PR #${PR_NUMBER} marked ready: $PR_URL"
      else
        echo "Warning: Could not create or find PR for branch $PHASE_BRANCH" >&2
      fi
    fi
    ```

    Store PR_NUMBER and PR_URL for offer_next output.

    **Note:** Phase worktree cleanup happens after PR merge, not here. The worktree remains so the PR branch stays valid. Users clean up after merge via:
    ```bash
    bash "./scripts/manage-worktree.sh" cleanup-phase "$PHASE_WORKTREE_PATH" "$PHASE_BRANCH"
    ```
```

Key changes from current step 10.5:
1. Replace `BRANCH=$(git branch --show-current)` with `$PHASE_BRANCH` (set in step 1.5)
2. Replace `git push` with `git -C "$PHASE_WORKTREE_PATH" push` (push from phase worktree)
3. Replace `gh pr list --head "$BRANCH"` with `gh pr list --head "$PHASE_BRANCH"`
4. Add planning state commit in phase worktree before push
5. Add cleanup note explaining worktree persists until PR merge

**Also modify step 10 (commit phase completion)** to add PR_WORKFLOW-conditional `-C` flags on every git command. Replace the step 10 bash block with:

```bash
DIR_NAME=$(basename "$PHASE_DIR")
if [ "$PR_WORKFLOW" = "true" ]; then
  GIT_DIR_FLAG=(-C "$PHASE_WORKTREE_PATH")
else
  GIT_DIR_FLAG=()
fi

# Stage deletions from previous locations (safe to try both)
git "${GIT_DIR_FLAG[@]}" add ".planning/phases/pending/${DIR_NAME}" 2>/dev/null || true
git "${GIT_DIR_FLAG[@]}" add ".planning/phases/active/${DIR_NAME}" 2>/dev/null || true
# Stage additions at current (completed) location
git "${GIT_DIR_FLAG[@]}" add "$PHASE_DIR"
# Stage planning files
git "${GIT_DIR_FLAG[@]}" add .planning/ROADMAP.md .planning/STATE.md
# Stage REQUIREMENTS.md if updated
git "${GIT_DIR_FLAG[@]}" add .planning/REQUIREMENTS.md 2>/dev/null || true
# Commit
git "${GIT_DIR_FLAG[@]}" commit -m "docs(${PHASE_NUM}): complete ${PHASE_NAME} phase"
```

The `GIT_DIR_FLAG` array pattern avoids duplicating every command. When PR_WORKFLOW=false the array is empty and `"${GIT_DIR_FLAG[@]}"` expands to nothing, preserving current behavior. When PR_WORKFLOW=true, all staging and commit operations target the phase worktree instead of main/.

Also update the verify checklist item for step 10: confirm no bare `git add` or `git commit` remain without the conditional `-C` flag.

**Do NOT modify** any other steps or sections.
  </action>
  <verify>
Read SKILL.md steps 10 and 10.5 and confirm:
1. Step 10 uses `GIT_DIR_FLAG` array pattern with PR_WORKFLOW conditional
2. Step 10 has no bare `git add` or `git commit` commands outside the conditional
3. Step 10.5 uses `$PHASE_BRANCH` not `git branch --show-current`
4. Step 10.5 uses `git -C "$PHASE_WORKTREE_PATH"` for push operations
5. References cleanup-phase for post-merge cleanup
6. `npm run build:plugin` succeeds
7. `npm test` passes
  </verify>
  <done>Steps 10 and 10.5 use phase worktree for all git operations when PR_WORKFLOW=true. No bare git commands target main/. Cleanup documented for post-merge.</done>
</task>

</tasks>

<verification>
- `npm run build:plugin` succeeds
- `npm test` passes
- SKILL.md contains no `git branch --show-current` in step 4 or 10.5 (replaced with PHASE_BRANCH)
- SKILL.md step 4 worktree create passes 3 args to manage-worktree.sh
- SKILL.md step 4 worktree merge passes 4 args to manage-worktree.sh
- SKILL.md step 10 uses `GIT_DIR_FLAG` array pattern conditional on PR_WORKFLOW
- SKILL.md step 10 has no bare `git add` or `git commit` outside the conditional
- SKILL.md step 10.5 uses `git -C "$PHASE_WORKTREE_PATH"` for push
- `grep -c "git -C main" SKILL.md` returns 0 (no hardcoded main/ references in worktree operations)
</verification>

<success_criteria>
- SKILL.md orchestrator execution flow uses phase worktrees for all git operations when PR_WORKFLOW=true
- Working directory injection covers three cases: plan worktree, phase worktree, no worktree
- manage-worktree.sh receive explicit phase branch and merge target args
- main/ directory never targeted by git checkout or git push during phase execution
</success_criteria>

<output>
After completion, create `.planning/phases/50-orchestrator-phase-worktree-lifecycle/50-01-SUMMARY.md`
</output>
